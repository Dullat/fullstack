
---

# ðŸ“¦ Node.js Modules (CommonJS)

In Node.js, **every file is a module**.

When you create:

```js
// app.js
```

It is automatically treated as a separate module with its own scope.

---

# ðŸ§  1ï¸âƒ£ How Node Executes a Module (Internals)

When you do:

```js
require("./file")
```

Node does:

1. Resolve the file path
    
2. Check `require.cache`
    
3. If not cached:
    
    - Read file
        
    - Wrap it like this:
        

```js
(function (exports, require, module, __filename, __dirname) {
   // your code here
});
```

4. Execute the function
    
5. Return `module.exports`
    
6. Cache the module
    

---

# ðŸ”’ 2ï¸âƒ£ Module Scope (Very Important)

Each file has its own private scope.

```js
// file1.js
const secret = "hidden";
```

```js
// file2.js
console.log(secret); âŒ ERROR
```

Why?

Because variables are NOT global.  
Each module is isolated.

---

# ðŸ“¤ 3ï¸âƒ£ Exporting Values

### âœ… Export Single Value

```js
module.exports = "hello";
```

Import:

```js
const value = require("./file");
```

---

### âœ… Export Function

```js
module.exports = function() {
  console.log("Hi");
};
```

---

### âœ… Export Multiple Things

```js
module.exports = {
  name: "Dullat",
  age: 25
};
```

Import:

```js
const { name, age } = require("./file");
```

---

# ðŸ” 4ï¸âƒ£ `exports` vs `module.exports`

At the start of a module:

```js
exports === module.exports // true
```

### This works:

```js
exports.name = "Dullat";
```

### This breaks:

```js
exports = { name: "Dullat" }; âŒ
```

Because you replaced the reference.

---

# ðŸ”¥ 5ï¸âƒ£ Module Caching

Modules run **only once**.

```js
require("./file");
require("./file");
```

File executes once.

Stored in:

```js
require.cache
```

---

### Why this is powerful:

You can create singletons.

```js
// db.js
const connection = createConnection();
module.exports = connection;
```

Every file gets the same connection instance.

---

# âš ï¸ 6ï¸âƒ£ Side Effects Problem

Bad pattern:

```js
// logger.js
console.log("Logger loaded");
connectToDatabase();
```

When imported, it runs immediately.

This is called a **side effect**.

### Why it's dangerous:

- Unexpected behavior
    
- Hard to test
    
- Hard to debug
    
- Executes before you control it
    

Better pattern:

```js
function init() {
  connectToDatabase();
}

module.exports = { init };
```

---

# ðŸ” 7ï¸âƒ£ Circular Dependency Problem

Example:

```js
// a.js
const b = require("./b");
module.exports = "A";
```

```js
// b.js
const a = require("./a");
module.exports = "B";
```

Problem:

When `a` loads:

- It loads `b`
    
- `b` tries to load `a`
    
- But `a` is not finished executing
    

You get partial exports.

This leads to weird bugs.

---

# ðŸ§¨ 8ï¸âƒ£ Overwriting `module.exports`

Bad:

```js
module.exports = () => {};
module.exports = "hello";
```

Only last one survives.

Common beginner mistake.

---

# ðŸ”„ 9ï¸âƒ£ Mutating Exported Objects

Example:

```js
// config.js
module.exports = { port: 3000 };
```

```js
// app.js
const config = require("./config");
config.port = 5000;
```

Now every other file sees port 5000.

Because exports are shared references.

This can cause hidden bugs.

---

# ðŸ§  10ï¸âƒ£ Execution Order Problem

When you import:

```js
require("./file");
```

Everything at top level runs immediately.

This can:

- Schedule async work
    
- Block event loop
    
- Log unexpectedly
    
- Change global state
    

Always remember:

> Import = Execute + Cache + Return exports

---

# ðŸ— 11ï¸âƒ£ Best Practices

### âœ… Keep top-level clean

Only define things, donâ€™t execute heavy logic.

### âœ… Export functions, not results

Better control.

### âœ… Avoid circular dependencies

Refactor shared logic into separate modules.

### âœ… Donâ€™t mutate imported configs

Treat imports as read-only.

### âœ… Use consistent export style

Either:

- Always `module.exports =`  
    OR
    
- Always `exports.something =`
    

Not mixed randomly.

---

# ðŸ†š 12ï¸âƒ£ CommonJS vs ES Modules

CommonJS:

```js
const x = require("./file");
module.exports = something;
```

ESM:

```js
import x from "./file.js";
export default something;
```

Key differences:

- ESM uses static analysis
    
- ESM has live bindings
    
- CJS exports are snapshots (values or references)
    

---

# ðŸŽ¯ Final Mental Model

Each file:

- Is wrapped in a function
    
- Has private scope
    
- Executes once
    
- Returns `module.exports`
    
- Is cached
    
- Shares exported references
    

---

# ðŸ’£ Real Problems You Will Face in Real Projects

1. Circular dependencies
    
2. Hidden side effects
    
3. Mutated shared objects
    
4. Mixing ESM and CommonJS
    
5. Accidentally overwriting `module.exports`
    
6. Forgetting that require runs immediately
    
7. Debugging execution order
    

---

# ðŸ§  Senior-Level Understanding

A Node module is:

> A singleton, cached, function-wrapped, scoped execution unit that returns a shared export reference.

If you deeply understand that sentence â€” you understand Node modules.

---

Next

- ðŸ”¥ Build your own mini `require()` implementation
    
- ðŸ”¥ Deep dive into module caching
    
- ðŸ”¥ Circular dependency simulation
    
- ðŸ”¥ ESM vs CommonJS internals comparison