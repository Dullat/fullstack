

---

# ğŸ§  1ï¸âƒ£ What Is a Writable Stream?

A Writable stream is something you can write data into.

Examples:

- `fs.createWriteStream()`
    
- HTTP response (`res`)
    
- `process.stdout`
    
- TCP socket
    
- Custom writable stream
    

Under the hood, Writable extends:

```js
const { Writable } = require("stream");
```

---

# ğŸ”¥ 2ï¸âƒ£ Basic Usage

```js
const fs = require("fs");

const ws = fs.createWriteStream("output.txt", {
  highWaterMark: 16 * 1024, // 16KB
  encoding: "utf8",
  flags: "w"
});

ws.write("Hello\n");
ws.write("World\n");

ws.end("Done\n"); // signals no more writes
```

Important:

- `.write()` â†’ sends chunk
    
- `.end()` â†’ final write + close
    

---

# ğŸ§  3ï¸âƒ£ What Happens Internally When You Call `.write()`?

Letâ€™s go deep.

When you call:

```js
ws.write(chunk);
```

Internally:

1. Chunk added to internal buffer
    
2. If not currently writing â†’ `_write()` is called
    
3. If buffer exceeds `highWaterMark` â†’ backpressure triggered
    
4. `.write()` returns boolean
    

---

# ğŸ”¥ 4ï¸âƒ£ Backpressure (VERY Important)

`.write()` returns:

```js
true  â†’ keep writing
false â†’ stop writing
```

Example:

```js
function writeMany(ws) {
  for (let i = 0; i < 100000; i++) {
    const ok = ws.write("Some large data\n");

    if (!ok) {
      console.log("Backpressure!");
      ws.once("drain", () => writeMany(ws));
      break;
    }
  }
}
```

If `.write()` returns false:

- Internal buffer is full
    
- You MUST wait for `'drain'`
    

This prevents memory explosion.

---

# ğŸ”¥ 5ï¸âƒ£ Important Writable Events

|Event|Meaning|
|---|---|
|`drain`|Buffer emptied, safe to write again|
|`finish`|All data flushed after `.end()`|
|`close`|Stream closed|
|`error`|Something failed|

Example:

```js
ws.on("finish", () => {
  console.log("All data written");
});
```

---

# ğŸ”¥ 6ï¸âƒ£ `highWaterMark` In Writable

In Writable:

- It defines how much data can be buffered before `.write()` returns false.
    

Default:

- 16KB (most writable streams)
    

If you set:

```js
highWaterMark: 1
```

Backpressure will trigger almost immediately.

---

# ğŸ”¥ 7ï¸âƒ£ Deep Dive: Internal Flow

Writable has:

```js
ws._writableState
```

Inside:

```js
{
  length: 0,
  writing: false,
  corked: 0,
  highWaterMark: 16384,
  buffer: []
}
```

When you call `.write()`:

```text
Add chunk to buffer
â†“
If not writing â†’ call _write()
â†“
Set writing = true
â†“
When _write finishes â†’ callback()
â†“
writing = false
â†“
Process next chunk
```

It processes chunks sequentially.

---

# ğŸ”¥ 8ï¸âƒ£ Create Your Own Writable (VERY IMPORTANT)

Now we build one.

```js
const { Writable } = require("stream");

class MyWritable extends Writable {
  constructor(options) {
    super(options);
  }

  _write(chunk, encoding, callback) {
    console.log("Writing chunk:", chunk.toString());

    setTimeout(() => {
      console.log("Finished writing chunk");
      callback(); // MUST call this
    }, 1000);
  }
}

const myStream = new MyWritable();

myStream.write("Hello");
myStream.write("World");
myStream.end();
```

Important:

- `_write()` is REQUIRED
    
- `callback()` signals completion
    
- If you donâ€™t call callback â†’ stream freezes
    

---

# ğŸ”¥ 9ï¸âƒ£ What If You Donâ€™t Call callback()?

Then:

- `writing = true` forever
    
- Buffer never drains
    
- `drain` never fires
    
- Stream deadlocks
    

This is common interview trap.

---

# ğŸ”¥ 10ï¸âƒ£ `write()` vs `_write()`

|Method|Who calls it|
|---|---|
|`.write()`|You|
|`._write()`|Node internally|

Never call `_write()` manually.

---

# ğŸ”¥ 11ï¸âƒ£ `end()` Internals

When you call:

```js
ws.end("last chunk");
```

Internally:

1. Final write
    
2. Marks stream as ending
    
3. Waits for buffer to flush
    
4. Emits `finish`
    
5. Closes fd
    

Important:

`finish` â‰  `close`

- `finish` â†’ data flushed
    
- `close` â†’ resource closed
    

---

# ğŸ”¥ 12ï¸âƒ£ Real Production Example (Copy File Safely)

```js
const { pipeline } = require("stream");
const fs = require("fs");

pipeline(
  fs.createReadStream("input.txt"),
  fs.createWriteStream("output.txt"),
  (err) => {
    if (err) console.error("Failed:", err);
    else console.log("Success");
  }
);
```

Writable side automatically handles:

- Backpressure
    
- Buffering
    
- Error propagation
    

---

# ğŸ”¥ 13ï¸âƒ£ Cork / Uncork (Now It Makes Sense)

```js
ws.cork();

ws.write("A");
ws.write("B");
ws.write("C");

process.nextTick(() => ws.uncork());
```

This batches writes before flushing.

Used in:

- HTTP responses
    
- TCP streams
    
- High-performance systems
    

---

# ğŸ”¥ 14ï¸âƒ£ Writable Stream Lifecycle

```text
new Writable()
â†“
.write()
â†“
_write()
â†“
buffer drains
â†“
.end()
â†“
finish
â†“
close
```

---

# ğŸ† Interview-Level Knowledge

You should be able to answer:

- What is backpressure?
    
- What does `.write()` return?
    
- What is `highWaterMark`?
    
- Difference between `finish` and `close`?
    
- What happens if `_write()` doesnâ€™t call callback?
    
- What is cork/uncork?
    

---

# ğŸš€ What Should Be Next After Writable?

After mastering Writable deeply:

1. Backpressure full system view (Readable â†” Writable)
    
2. `pipe()` internals
    
3. `pipeline()` internals
    
4. Transform streams
    
5. Implement your own Duplex
    
6. Stream performance tuning
    

---
