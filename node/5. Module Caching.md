

# ğŸ“¦ What Is Module Caching in Node.js?

**Module caching means:**

> When you `require()` a file, Node executes it once, stores the result, and reuses it for future `require()` calls.

It does NOT execute the file again.

---

# ğŸ§  Step-by-Step: What Happens When You `require()`

When you do:

```js
require("./file");
```

Node:

1. Resolves full path
    
2. Checks `require.cache`
    
3. If NOT cached:
    
    - Loads file
        
    - Wraps it in a function
        
    - Executes it
        
    - Stores it in cache
        
4. Returns `module.exports`
    

If cached:

ğŸ‘‰ Skips execution  
ğŸ‘‰ Immediately returns stored `module.exports`

---

# ğŸ”¥ Example

### file.js

```js
console.log("File executed");

module.exports = {
  counter: 0
};
```

---

### app.js

```js
const a = require("./file");
const b = require("./file");

console.log("Done");
```

---

### Output:

```
File executed
Done
```

Notice:

Even though we required it twice,  
it executed only once.

Thatâ€™s module caching.

---

# ğŸ“‚ Where Is It Stored?

In:

```js
require.cache
```

You can inspect it:

```js
console.log(require.cache);
```

Itâ€™s an object where:

- Key = full file path
    
- Value = module object
    

---

# ğŸ”¥ Proving Itâ€™s Cached

Try this:

```js
console.log(require.cache[require.resolve("./file")]);
```

That shows the cached module info.

---

# ğŸš€ Why Module Caching Exists

### 1ï¸âƒ£ Performance

Without caching:

- Every require would re-read file
    
- Re-parse JS
    
- Re-execute code
    

That would be slow.

---

### 2ï¸âƒ£ Singleton Pattern

This is powerful.

Example:

```js
// db.js
const connection = { id: Math.random() };
module.exports = connection;
```

```js
// app.js
const db1 = require("./db");
const db2 = require("./db");

console.log(db1 === db2); // true
```

Because cached object is shared.

---

# ğŸ§  Important: It Caches the EXPORT, Not Just Code

If you export an object:

```js
module.exports = { count: 0 };
```

Every file that imports it gets the SAME object reference.

---

# âš ï¸ Real Problem: Shared State Bug

Example:

```js
// config.js
module.exports = { port: 3000 };
```

```js
// file1.js
const config = require("./config");
config.port = 5000;
```

```js
// file2.js
const config = require("./config");
console.log(config.port); // 5000 ğŸ˜³
```

Why?

Because itâ€™s the SAME cached object.

This causes hidden bugs in large apps.

---

# ğŸ”„ You Can Clear Cache (Advanced)

```js
delete require.cache[require.resolve("./file")];
```

Then:

```js
require("./file"); // executes again
```

Used in:

- Testing
    
- Hot reload systems
    
- Dev tools
    

---

# ğŸ§  Circular Dependency + Cache

Module caching also helps with circular dependencies.

When file A loads file B, and B loads A:

Node puts A into cache BEFORE finishing execution.

So B receives a partial export of A.

Thatâ€™s why circular deps cause weird â€œundefinedâ€ issues.

---

# ğŸ¯ Execution Timeline Example

```js
// file.js
console.log("running");
module.exports = "hello";
```

```js
require("./file"); // executes
require("./file"); // returns cached
```

Timeline:

```
First require:
  -> execute file
  -> cache module
  -> return "hello"

Second require:
  -> return cached "hello"
```

---

# ğŸ§© What Exactly Is Cached?

The entire module object:

```js
{
  id,
  filename,
  loaded,
  exports,
  children,
  paths
}
```

Most important part:

```
module.exports
```

---

# ğŸ§  Senior-Level Mental Model

Node modules are:

- Executed once
    
- Cached by absolute path
    
- Shared by reference
    
- Act as singletons
    

---

# ğŸ’£ Real-World Issues With Caching

1. Unexpected shared state
    
2. Hard-to-debug mutations
    
3. Circular dependency partial exports
    
4. Memory usage if too many modules loaded
    
5. Problems during testing (mocking modules)
    

---

# ğŸ† When Should You Use This Knowledge?

- Creating database connections
    
- Creating config singletons
    
- Writing caching layers
    
- Writing libraries
    
- Building dependency injection systems
    

---

Test  understanding:

If a module exports:

```js
module.exports = { count: 0 };
```

And in one file you do:

```js
const counter = require("./counter");
counter.count++;
```

What will another file see when it requires it?