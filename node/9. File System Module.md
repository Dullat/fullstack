# ğŸ”¥ `fs` Module â€” Deep Dive (Internal + Real World)

`fs` = **File System**

It lets Node interact with the OS file system through **libuv**.

You already studied:

- Event loop
    
- libuv
    
- threads
    

So now we connect everything.

---

# ğŸ§  1ï¸âƒ£ What `fs` Actually Is Internally

Node does NOT implement file system logic itself.

It delegates to:

> libuv â†’ which delegates to OS syscalls

Flow:

```
Your JS code
   â†“
Node C++ bindings
   â†“
libuv
   â†“
OS system calls
   â†“
Disk
```

So when you call:

```js
fs.readFile()
```

It goes into C++ bindings, then into libuvâ€™s thread pool.

---

# ğŸ§  2ï¸âƒ£ Why There Are 3 Types of FS APIs

Node gives you:

1. Synchronous
    
2. Callback-based async
    
3. Promise-based async
    

Letâ€™s understand why.

---

# ğŸ”¥ 3ï¸âƒ£ Synchronous FS (Blocking)

Example:

```js
const data = fs.readFileSync("file.txt", "utf8");
```

What happens:

- JS thread blocks
    
- Event loop pauses
    
- Nothing else runs
    
- Node waits until file is read
    

This is fine for:

- CLI tools
    
- Startup config loading
    

Bad for:

- Servers
    
- High concurrency apps
    

Because:

> It blocks the single-threaded event loop.

---

# ğŸš€ 4ï¸âƒ£ Async FS (Callback)

Example:

```js
fs.readFile("file.txt", "utf8", (err, data) => {
   console.log(data);
});
```

What happens internally:

1. JS calls fs.readFile
    
2. Node hands task to libuv
    
3. libuv sends to thread pool
    
4. Thread reads file
    
5. Completion queued in event loop
    
6. Callback executed
    

Main thread is FREE meanwhile.

This is true non-blocking behavior.

---

# ğŸ§  5ï¸âƒ£ Thread Pool Connection (Very Important)

libuv has:

> Default 4 threads

Used for:

- fs operations
    
- crypto
    
- DNS
    
- compression
    

You can change it:

```bash
UV_THREADPOOL_SIZE=8 node app.js
```

Max = 128

If you run heavy fs operations concurrently,  
you can saturate thread pool.

Thatâ€™s real-world scaling knowledge.

---

# ğŸ§  6ï¸âƒ£ Promise Version

```js
import fs from "fs/promises";

const data = await fs.readFile("file.txt", "utf8");
```

Internally:

- Same as callback version
    
- Just wrapped in Promise
    

No performance difference.

There are **two correct ways** to use `fs` with `async/await`.

---

### âœ… Method 1 (Recommended) â€” Use `fs/promises`

This is the clean modern way.


```js
const fs = require('fs/promises');

async function readMyFile() {
  try {
    const data = await fs.readFile('file.txt', 'utf8');
    console.log(data);
  } catch (err) {
    console.error('Error:', err.message);
  }
}

readMyFile();

```

### âœ” Whatâ€™s happening?

- `fs.readFile()` returns a Promise
    
- `await` waits for it
    
- If error happens â†’ it goes to `catch`
    

---

### âœ… Method 2 â€” Convert callback version to promise

If you're using normal `fs`:

```js
const fs = require('fs');
const util = require('util');

const readFile = util.promisify(fs.readFile);

async function readMyFile() {
  try {
    const data = await readFile('file.txt', 'utf8');
    console.log(data);
  } catch (err) {
    console.error(err);
  }
}

```
But âš ï¸ this is old style. Prefer `fs/promises`.

---

# ğŸ§  Writing Files with async/await

```js
const fs = require('fs/promises');

async function writeFileExample() {
  try {
    await fs.writeFile('test.txt', 'Hello world');
    console.log('File written!');
  } catch (err) {
    console.error(err);
  }
}

```
---

# ğŸ§  Creating Directory + Writing File (Real Backend Pattern)

```js
const fs = require('fs/promises');
const path = require('path');

async function saveFile() {
  const filePath = 'downloads/uploads/data.txt';

  try {
    await fs.mkdir(path.dirname(filePath), { recursive: true });
    await fs.writeFile(filePath, 'Some data');

    console.log('Success');
  } catch (err) {
    console.error(err);
  }
}

```

---

### ğŸ§  Parallel Async Example (Important for Backend)

```js
const fs = require('fs/promises');

async function readTwoFiles() {
  try {
    const [file1, file2] = await Promise.all([
      fs.readFile('a.txt', 'utf8'),
      fs.readFile('b.txt', 'utf8')
    ]);

    console.log(file1, file2);
  } catch (err) {
    console.error(err);
  }
}

```
ğŸ‘‰ This runs both at same time (better performance).

---

# ğŸ”¥ 7ï¸âƒ£ File Descriptors (Deep System Level)

When you open a file:

```js
fs.open()
```

OS returns:

> File Descriptor (integer)

Example:

```
3
4
5
```

These are handles to OS-level file table.

When you use:

```js
fs.readFile()
```

Node internally:

- Opens file
    
- Reads it
    
- Closes it
    

But with `fs.open()`:  
You manage descriptor manually.

Advanced servers use this for:

- Performance optimization
    
- Streaming
    
- Partial reads
    

---

# ğŸš€ 8ï¸âƒ£ Streams (Very Important in Production)

Reading full file:

```js
fs.readFile()
```

Loads entire file into memory.

Bad for large files.

Instead:

```js
const stream = fs.createReadStream("bigfile.txt");
```

This:

- Reads in chunks
    
- Uses backpressure
    
- Works with event loop efficiently
    

Streams are how:

- Video servers work
    
- File upload systems work
    
- Proxy servers work
    

---

# ğŸ§  9ï¸âƒ£ Under The Hood: Why FS Is Not Truly "Non-Blocking"

Important concept:

Disk IO is blocking at OS level.

Node makes it â€œnon-blockingâ€ by:

- Offloading to thread pool
    
- Returning control to event loop
    

So it is:

> Thread-based async

Not event-driven like sockets.

Networking uses epoll/kqueue.  
File system uses threads.

This is advanced distinction.

---

# ğŸ”¥ 1ï¸âƒ£0ï¸âƒ£ Common FS Methods (With Deep Context)

---

## `fs.readFile()`

Good for:

- Small files
    
- Config
    
- JSON
    

Bad for:

- Large data
    

---

## `fs.writeFile()`

Overwrites file.

Atomic writes?  
Not guaranteed unless handled carefully.

Production systems often:

- Write to temp file
    
- Rename it
    

---

## `fs.appendFile()`

Adds at end.

Used in:

- Logging systems
    

But high-scale logging uses streams instead.

---

## `fs.mkdir()`

With:

```js
{ recursive: true }
```

Important for:

- File upload systems
    
- Dynamic folder creation
    

---

## `fs.rm()`

Modern replacement for `unlink` + `rmdir`.

Example:

```js
fs.rm("folder", { recursive: true, force: true });
```

---

# ğŸ§  1ï¸âƒ£1ï¸âƒ£ Real Production Example: File Upload API

In Express:

```js
const uploadPath = path.join(__dirname, "uploads", fileName);

await fs.mkdir(path.dirname(uploadPath), { recursive: true });

await fs.writeFile(uploadPath, fileBuffer);
```

This ensures:

- Cross-platform safety
    
- Dynamic directory creation
    
- Async non-blocking behavior
    

---

# ğŸ§  1ï¸âƒ£2ï¸âƒ£ Performance Insight

Bad:

```js
for (let i = 0; i < 1000; i++) {
   fs.readFileSync("file.txt");
}
```

Blocks entire server.

Better:

```js
Promise.all([...Array(1000)].map(() =>
   fs.promises.readFile("file.txt")
));
```

But still limited by thread pool.

Real scaling solution:

- Caching
    
- Streaming
    
- Queueing
    
- Worker threads
    

---

# ğŸ”¥ 1ï¸âƒ£3ï¸âƒ£ Watching Files

```js
fs.watch()
```

Used for:

- Nodemon
    
- Dev servers
    
- Build tools
    

Internally:

- Uses OS file system events
    

Not 100% reliable across platforms.  
Thatâ€™s why tools implement fallbacks.

---

# ğŸ§  1ï¸âƒ£4ï¸âƒ£ Security Concerns (Critical)

If you allow user input paths:

```js
fs.readFile(req.query.path);
```

You risk:

> Path traversal attack

Example:

```
../../etc/passwd
```

Always validate paths using:

- `path.resolve`
    
- `path.normalize`
    
- Restrict base directory
    

---

# ğŸ§  1ï¸âƒ£5ï¸âƒ£ Scaling Knowledge

For high-scale systems:

- Avoid sync methods
    
- Avoid reading large files fully
    
- Use streams
    
- Control thread pool
    
- Use caching layer
    
- Consider object storage (S3 etc.)
    
- Avoid disk when possible
    

---

# ğŸ§  1ï¸âƒ£6ï¸âƒ£ Event Loop Phase Connection

FS callbacks go into:

> Poll phase

Understanding this helps debug timing issues.

---

# ğŸ¯ Final Mental Model

Think of `fs` as:

> A bridge between JavaScript and OS file system powered by libuv thread pool.

It is:

- Not magic
    
- Not truly async at disk level
    
- Just abstracted threads
    

---


---

Next deep topics :

- ğŸ”¥ Streams deep internals
    
- ğŸ§  Backpressure mechanics
    
- âš™ï¸ How libuv thread pool really works
    
- ğŸ“¦ How Node handles large file uploads
    
- ğŸš€ Worker threads vs fs
    
- âš”ï¸ Performance benchmarking
    
- ğŸ§¬ Building your own mini fs wrapper