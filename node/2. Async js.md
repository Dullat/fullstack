

---

# ðŸ§  ASYNC JAVASCRIPT â€” COMPLETE MAP 

---

## 1ï¸âƒ£ JavaScript execution model (MOST IMPORTANT)

Before async, you must know **how JS runs at all**.

### âœ… Single-threaded

- One call stack
    
- One thing executing at a time
    
- No true parallelism in JS itself
    

### âœ… Call Stack

- Where functions go when theyâ€™re running
    
- LIFO (last in, first out)
    

```js
function a() {
  b();
}
function b() {
  c();
}
a();
```

Stack at peak:

```
c
b
a
global
```

ðŸ‘‰ Async JS exists **because** the stack must stay free.

---

## 2ï¸âƒ£ Blocking vs Non-Blocking

### Blocking (bad)

```js
const data = readFileSync("big.txt");
console.log("done"); // waits
```

### Non-blocking (async)

```js
readFile("big.txt", () => {
  console.log("done");
});
```

ðŸ‘‰ Async JS lets slow work happen **outside the stack**.

---

## 3ï¸âƒ£ Web APIs / Runtime APIs (not JavaScript!)

This is a BIG misconception.

Things like:

- `setTimeout`
    
- `fetch`
    
- DOM events
    
- File I/O (Node)
    

âŒ These are NOT JS  
âœ… They are provided by the **environment** (browser / Node)

JS only knows how to:

- call them
    
- register callbacks
    

---

## 4ï¸âƒ£ Event Loop (core async concept)

The **event loop** decides:

> â€œWhen can I safely put this callback back on the stack?â€

Basic cycle:

```
Run JS
â†“
Stack empty?
â†“
Run queued callbacks
â†“
Repeat
```

JS never multitasks â€” it **schedules**.

---

## 5ï¸âƒ£ Task queues (VERY important)

Async JS is all about **queues**.

### ðŸŸ¨ Macrotask queue

- `setTimeout`
    
- `setInterval`
    
- I/O
    
- UI events
    

### ðŸŸ© Microtask queue

- `Promise.then`
    
- `catch`
    
- `finally`
    
- `async/await`
    

### Priority

```
Microtasks > Macrotasks
```

---

## 6ï¸âƒ£ Callbacks (first async abstraction)

### What they are

A function passed to be called later.

```js
setTimeout(() => {
  console.log("done");
}, 1000);
```

### Problems

- Callback hell
    
- Inversion of control
    
- Error handling
    

Still important to understand â€” many APIs started here.

---

## 7ï¸âƒ£ Promises (async state machine)

### Promise = future value

States:

```
pending â†’ fulfilled
pending â†’ rejected
```

### Key properties

- Settles once
    
- Immutable
    
- Chainable
    

### Core methods

- `.then`
    
- `.catch`
    
- `.finally`
    

### Promise queues

Promise callbacks go into the **microtask queue**.

---

## 8ï¸âƒ£ Promise chaining (critical skill)

```js
fetch(url)
  .then(r => r.json())
  .then(data => process(data))
  .catch(err => handle(err));
```

Rules you must know:

- `.then()` always returns a Promise
    
- returning a value â†’ resolves
    
- throwing â†’ rejects
    
- returning a Promise â†’ waits
    

---

## 9ï¸âƒ£ async / await (syntax over Promises)

### What it is

Syntactic sugar over `.then()`.

```js
async function f() {
  const data = await fetch(url);
  return data;
}
```

### What `await` does

- Pauses the function
    
- Releases the stack
    
- Resumes via microtask
    

â— It does NOT block JS.

---

## ðŸ”Ÿ Error handling in async JS

### Callbacks

```js
(err, data) => {}
```

### Promises

```js
.catch(err => {})
```

### async/await

```js
try {
  await f();
} catch (e) {}
```

Knowing **where errors propagate** is essential.

---

## 1ï¸âƒ£1ï¸âƒ£ Promise combinators (real-world async)

### Parallel

```js
Promise.all([p1, p2]);
```

### Tolerant

```js
Promise.allSettled([...]);
```

### Fastest

```js
Promise.race([...]);
```

### First success

```js
Promise.any([...]);
```

Used constantly in APIs.

---

## 1ï¸âƒ£2ï¸âƒ£ Timing functions

- `setTimeout`
    
- `setInterval`
    
- `clearTimeout`
    
- `clearInterval`
    

Key truth:

> `setTimeout(fn, 0)` â‰  immediate

Timers depend on:

- event loop
    
- call stack
    
- system timing
    

---

## 1ï¸âƒ£3ï¸âƒ£ Async iteration

### for await...of

```js
for await (const chunk of stream) {
  console.log(chunk);
}
```

Used for:

- streams
    
- paginated APIs
    
- async generators
    

---

## 1ï¸âƒ£4ï¸âƒ£ Async patterns (important concepts)

### Sequential

```js
await a();
await b();
```

### Parallel

```js
await Promise.all([a(), b()]);
```

### Throttling / batching

- limit concurrency
    
- avoid overload
    

---

## 1ï¸âƒ£5ï¸âƒ£ Common async mistakes (know these)

âŒ Trying to return async data synchronously  
âŒ Forgetting `await`  
âŒ Wrapping Promises in `new Promise`  
âŒ Mixing callbacks and promises incorrectly  
âŒ Blocking CPU in async code

---

## 1ï¸âƒ£6ï¸âƒ£ Browser vs Node async differences (conceptual)

### Browser

- Rendering
    
- User events
    
- No `process.nextTick`
    

### Node

- File system
    
- Network
    
- `process.nextTick`
    
- `setImmediate`
    

Same language, different runtimes.

---

## 1ï¸âƒ£7ï¸âƒ£ Mental model (this is the core)

> JavaScript never waits.  
> Async work happens outside JS.  
> The event loop schedules callbacks when the stack is free.  
> Promises and async/await are just cleaner ways to express this.

---

## âœ… Final async-JS checklist (use this)

You should be confident about:

âœ” Call stack  
âœ” Event loop  
âœ” Microtask vs macrotask  
âœ” Callbacks  
âœ” Promises  
âœ” async/await  
âœ” Error propagation  
âœ” Parallel vs sequential async  
âœ” Promise combinators