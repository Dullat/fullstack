
---

# Event Loop â€” From Absolute Zero

Forget Node for a moment.

## Step 1: What JavaScript REALLY is

JavaScript is:

- **Single-threaded**
    
- **Synchronous by default**
    
- **Has ONE call stack**
    

Thatâ€™s it.

```js
function a() {
  b();
}
function b() {
  c();
}
function c() {}

a();
```

### Whatâ€™s happening

- `a()` pushed to stack
    
- `b()` pushed
    
- `c()` pushed
    
- pop `c`, pop `b`, pop `a`
    

If one function blocks â†’ **everything blocks**.

---

## Step 2: The problem JS had

JS wanted to:

- Wait for timers
    
- Read files
    
- Handle network requests
    

But JS **cannot wait** â€” it has one thread.

So the question became:

> How do we let JS _start_ slow work without _waiting_?

---

## Step 3: The solution (important sentence)

> **JavaScript does not do async work. The environment does.**

Browser or Node â€” same idea.

JS just says:

```js
â€œHey environment, do this and call me back later.â€
```

---

## Step 4: Enter Node.js architecture (mental model)

Think of Node like this:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Call Stack   â”‚  â† JS runs here (ONE thread)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Event Loop (libuv)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OS / Thread Pool     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

JS never touches threads.  
JS never touches OS.

Node does that **for** JS.

---

## Step 5: Your first async example (DEMO)

```js
console.log("A");

setTimeout(() => {
  console.log("B");
}, 0);

console.log("C");
```

### Step-by-step execution

1. `console.log("A")` â†’ stack â†’ print A
    
2. `setTimeout(...)`
    
    - Timer registered in **libuv**
        
    - Callback stored
        
3. `console.log("C")` â†’ print C
    
4. Call stack empty
    
5. Event loop says: â€œany callbacks ready?â€
    
6. Timer expired â†’ push callback â†’ print B
    

**Output**

```
A
C
B
```

ðŸ’¡ `0` does NOT mean â€œnowâ€.  
It means **â€œafter stack is emptyâ€**.

---

## Step 6: Event Loop = traffic police

Event loopâ€™s job:

- Watch queues
    
- Push callbacks onto stack **only when stack is empty**
    

JS never pulls tasks.  
Event loop **pushes**.

---

## Step 7: But Node has MULTIPLE queues ðŸ˜ˆ

This is where people get lost.

Node has:

- **Microtask queue**
    
- **Macrotask queues (phases)**
    

### Important rule (memorize)

> **Microtasks always run before the event loop moves to the next phase.**

---

## Step 8: Microtasks (Promise, nextTick)

```js
console.log("A");

Promise.resolve().then(() => {
  console.log("B");
});

console.log("C");
```

### Execution

1. A
    
2. Promise callback â†’ microtask queue
    
3. C
    
4. Stack empty
    
5. Microtasks flushed
    
6. B
    

**Output**

```
A
C
B
```

---

## Step 9: Promise vs setTimeout (classic trap)

```js
setTimeout(() => console.log("timeout"), 0);

Promise.resolve().then(() => console.log("promise"));
```

### Why?

- Promises â†’ **microtasks**
    
- `setTimeout` â†’ **timers phase**
    

Microtasks **always win**.

**Output**

```
promise
timeout
```

---

## Step 10: Node-only weapon: `process.nextTick`

```js
process.nextTick(() => console.log("tick"));

Promise.resolve().then(() => console.log("promise"));
```

### Priority order (Node)

1. `process.nextTick`
    
2. Promise microtasks
    
3. Event loop phases
    

**Output**

```
tick
promise
```

âš ï¸ Abuse of `nextTick` can STARVE the event loop.

---

## Step 11: Full Node Event Loop Phases (now we name them)

Order:

1. **Timers** â€“ `setTimeout`, `setInterval`
    
2. **I/O callbacks**
    
3. **Idle, prepare**
    
4. **Poll** â† waits for I/O
    
5. **Check** â€“ `setImmediate`
    
6. **Close callbacks**
    

Between **every phase**:

- `process.nextTick`
    
- Promises run
    

---

## Step 12: The fs confusion (thread pool)

```js
const fs = require("fs");

fs.readFile("a.txt", () => {
  console.log("file");
});
```

What really happens:

1. JS â†’ libuv
    
2. libuv â†’ **thread pool**
    
3. Thread reads file
    
4. Callback queued in **poll phase**
    
5. Event loop executes it
    

JS thread was **never blocked**.

---

## Step 13: Final mental model (lock this in)

> **JS runs code.  
> Node delegates slow work.  
> Event loop schedules callbacks.**

If stack is busy â†’ nothing runs.  
If stack is empty â†’ event loop acts.

---

---

# 1ï¸âƒ£ Poll vs Check â€” the real difference

### First: what these phases are _for_

**Poll phase**

- Where Node:
    
    - waits for I/O (sockets, fs callbacks, etc.)
        
    - executes I/O callbacks
        
- This is where Node spends **most of its life**
    

**Check phase**

- Exists basically for **`setImmediate`**
    
- Runs _after_ poll
    

Think of it like:

> **Poll = â€œdo useful work or waitâ€**  
> **Check = â€œrun immediates before next loopâ€**

---

## The golden rule (memorize this)

> **`setImmediate` runs AFTER the poll phase**  
> **`setTimeout(0)` runs in the NEXT timers phase**

Thatâ€™s it. Everything else flows from this.

---

## The classic confusion example

```js
setTimeout(() => console.log("timeout"), 0);
setImmediate(() => console.log("immediate"));
```

### What prints first?

ðŸ‘‰ **Unpredictable** (from top-level code)

Why?

- If poll phase is empty â†’ Node may jump to check
    
- Or timers phase may run first
    

ðŸ’¥ **This is intentional behavior**

---

## But inside I/Oâ€¦ order becomes deterministic ðŸ˜ˆ

```js
const fs = require("fs");

fs.readFile("a.txt", () => {
  setTimeout(() => console.log("timeout"), 0);
  setImmediate(() => console.log("immediate"));
});
```

### Output (always):

```
immediate
timeout
```

### WHY (this is the money part)

1. `fs.readFile` callback runs in **poll phase**
    
2. Inside poll:
    
    - `setImmediate` â†’ queued for **check**
        
    - `setTimeout` â†’ queued for **next timers**
        
3. Poll phase finishes
    
4. **Check phase runs immediately**
    
5. Timers must wait for next loop iteration
    

ðŸŽ¯ This is _why `setImmediate` exists_.

---

## Mental picture

```text
poll phase
 â”œâ”€ fs callback runs
 â”œâ”€ schedule setImmediate â†’ check queue
 â””â”€ schedule setTimeout â†’ timers queue

check phase
 â””â”€ run setImmediate

(next loop)
timers phase
 â””â”€ run setTimeout
```

---

# 2ï¸âƒ£ Are Promises & nextTick part of the event loop?

This is a **very sharp question**. Answer carefully:

### Short truth

> **They are NOT event loop phases.  
> They are NOT part of libuvâ€™s loop.**

Butâ€¦

> **They ARE executed _by Node_ between event loop phases.**

Letâ€™s unpack that.

---

## Who owns what?

### libuv (C)

- Timers
    
- Poll
    
- Check
    
- I/O
    
- Thread pool
    
- OS integration
    

### V8 (JS engine)

- Call stack
    
- Heap
    
- Microtask queue (**Promises**)
    

### Node.js (the glue)

- Decides _when_ to flush:
    
    - `process.nextTick`
        
    - V8 microtasks
        

---

## Where `Promise.then()` lives

- Promise callbacks live in **V8â€™s microtask queue**
    
- V8 knows nothing about libuv phases
    

Node does this:

> â€œAfter every JS callback, before returning to libuv, flush microtasks.â€

So:

- Not a phase
    
- But **higher priority than any phase**
    

---

## Where `process.nextTick` lives (Node-only)

- Implemented by **Node itself**
    
- Not in V8
    
- Not in libuv
    

Node rule:

> â€œBefore running microtasks, flush nextTick queue.â€

Thatâ€™s why it beats Promises.

---

## The REAL execution order (precise)

Whenever JS finishes running **any callback**:

1. `process.nextTick` queue
    
2. V8 microtasks (Promises)
    
3. Return control to **libuv event loop**
    

Then libuv chooses the next phase.

---

## Why this distinction matters (production bug territory)

### Event loop starvation

```js
function loop() {
  process.nextTick(loop);
}
loop();
```

ðŸ’€ Poll phase NEVER runs  
ðŸ’€ No timers  
ðŸ’€ No I/O  
ðŸ’€ CPU 100%

Because Node never returns control to libuv.

---

## Interview-safe explanation (say this)

> **Promises and `process.nextTick` are not event loop phases. They are microtask mechanisms that Node executes between event loop phases, with `nextTick` having higher priority than Promises.**

That sentence alone = senior signal.

---

## Final mental model (lock it)

```
JS callback finishes
 â†“
nextTick queue
 â†“
Promise microtasks
 â†“
libuv event loop phase
```

---
