Letâ€™s go deep into:

- `require` (CommonJS)
    
- `import` (ESM)
    
- How Node loads them internally
    
- Why they behave differently
    
- Why ESM has no `__dirname`
    
- Why ESM is async
    
- How caching works
    
- How resolution works
    


---

# ðŸ§  1ï¸âƒ£ How Node Executes a File (CommonJS Internals)

When you run:

```bash
node app.js
```

Node does NOT just execute the file directly.

Internally it wraps it like this:

```js
(function (exports, require, module, __filename, __dirname) {
   // your code
});
```

This is called:

> The CommonJS module wrapper

Thatâ€™s why inside any `.js` file (without `"type": "module"`):

You automatically get:

- `require`
    
- `module`
    
- `exports`
    
- `__filename`
    
- `__dirname`
    

They are NOT global variables.  
They are parameters passed into this wrapper function.

---

# ðŸ§  2ï¸âƒ£ How `require()` Actually Works (Step-by-Step)

When you do:

```js
const x = require("./math");
```

Node does:

### Step 1 â€” Resolve the path

It converts `"./math"` into an absolute path.

It tries:

```
./math.js
./math.json
./math.node
./math/index.js
```

This process is called:

> Module Resolution Algorithm

---

### Step 2 â€” Check Cache

Node has an internal cache:

```js
require.cache
```

If module already loaded:

â†’ return cached `exports`

If not:

â†’ continue

---

### Step 3 â€” Load File

- Read file content
    
- Wrap in module wrapper
    
- Compile with V8
    
- Execute immediately (synchronously)
    

---

### Step 4 â€” Store in Cache

The result (`module.exports`) is stored.

Next time you call require:

It does NOT execute again.

It returns cached object.

---

# ðŸ§  3ï¸âƒ£ Why `require` Is Synchronous

Because:

- It was designed for server environments
    
- Disk access assumed local
    
- Blocking at startup is acceptable
    
- Simpler design
    

Thatâ€™s why this works:

```js
const config = require("./config");
```

Immediately available.

---

# ðŸš€ Now Letâ€™s Switch to ESM

When you enable:

```json
{
  "type": "module"
}
```

Node does NOT use the wrapper.

Instead it follows:

> The ECMAScript Module Specification

This is the official JavaScript standard.

---

# ðŸ§  4ï¸âƒ£ How `import` Works Internally

When you write:

```js
import { add } from "./math.js";
```

Node does 3 distinct phases:

---

## Phase 1 â€” Parsing (Static Analysis)

Before running anything:

Node scans ALL imports.

This is why:

```js
import x from somethingDynamic(); âŒ
```

is illegal.

Imports must be static.

Because ESM needs to build a dependency graph first.

---

## Phase 2 â€” Linking

Node creates:

> Module dependency graph

Example:

```
app.js
  â†³ math.js
      â†³ helper.js
```

It links all modules BEFORE executing any of them.

This is fundamentally different from require.

---

## Phase 3 â€” Evaluation

Then Node executes modules in correct order.

This is why ESM supports:

```js
top-level await
```

Because evaluation phase can be async.

---

# ðŸ”¥ Why ESM Is Async Internally

Because:

- It supports remote URLs (in spec)
    
- It builds full dependency graph first
    
- It supports top-level await
    

Even though in Node it _looks_ synchronous,  
internally it is asynchronous.

---

# ðŸ§  5ï¸âƒ£ Why `__dirname` Does Not Exist in ESM

CommonJS:

```
File = plain file path
Wrapped in function
```

ESM:

```
Module = URL-based resource
```

In ESM, modules are treated as URLs:

```js
console.log(import.meta.url);
```

Example output:

```
file:///home/user/app.js
```

Thatâ€™s why:

- There is no wrapper
    
- No injected `__filename`
    
- No injected `__dirname`
    

Instead, we derive it manually from URL.

---

# ðŸ§  6ï¸âƒ£ Caching Difference

CommonJS:

```js
require.cache
```

Mutable exports.  
You can even modify cached module.

ESM:

- Live bindings
    
- Read-only views
    
- More predictable behavior
    

Example:

CommonJS:

```js
exports.count = 0;
```

Can be mutated anywhere.

ESM:

```js
export let count = 0;
```

Importers get live reference.

Thatâ€™s a big design difference.

---

# ðŸ§  7ï¸âƒ£ Circular Dependency Difference

CommonJS:

- Executes immediately
    
- Returns partially initialized module
    

ESM:

- Handles cycles more safely
    
- Uses live bindings
    
- Better execution ordering
    

This is one reason modern tooling prefers ESM.

---

# ðŸ§  8ï¸âƒ£ Why Big Ecosystem Is Moving Toward ESM

Because:

- Itâ€™s standard JS
    
- Works in browsers
    
- Supports tree-shaking
    
- Enables better static analysis
    
- Enables better bundling
    
- Enables top-level await
    

CommonJS is Node-specific.

ESM is JavaScript-standard.

---

# ðŸŽ¯ So Whatâ€™s Used in Real Backend Apps?

Today:

- Old Express APIs â†’ CommonJS
    
- New backend frameworks â†’ ESM
    
- Libraries â†’ increasingly ESM-only
    
- Monorepos â†’ often mixed
    

In 2026:

> ESM is becoming default for new projects.

But CommonJS is still heavily used.

---

# ðŸ§  Senior-Level Understanding

Hereâ€™s the real mental model:

CommonJS:

- Dynamic
    
- Runtime-based
    
- Synchronous
    
- Node-invented
    

ESM:

- Static
    
- Graph-based
    
- Async internally
    
- Language-level standard
    

They are two different loading systems.

Not just syntax difference.

---

# Next

We can go into:

- How Node resolves `node_modules` step by step
    
- How package.json `exports` field works
    
- How dual packages support both CJS and ESM
    
- How dynamic `import()` works
    
- How to write hybrid libraries
    
- Why top-level await only works in ESM
    
- How bundlers exploit ESM static structure