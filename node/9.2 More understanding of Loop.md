

---

# ğŸ“ Node.js Async & Execution Context â€” Example-Based Note

### **Example Code**

```js
const fs = require("fs");
const fsAwait = require("fs/promises");
const os = require("os");
const path = require("path");
const process = require("process");
const chalk = require("chalk");

// ---------------- Sync FS ----------------
console.log(chalk.bgYellow.black("############### Sync file ############"));
const filePath = path.join(os.tmpdir(), "temp.txt");
fs.writeFileSync(filePath, "hi this is me, dullat jatt...", "utf8");
const data = fs.readFileSync(filePath, "utf8");
console.log(data);

// Append text using sync method
fs.writeFileSync(filePath, "\nappending this text..", { flag: "a" });

// ---------------- Async FS ----------------
fs.readFile(filePath, (err, data) => {
  console.log(chalk.bgGreen.black("############### Async file ############"));
  console.log(data.toString());
});

// ---------------- Promise FS ----------------
async function readData() {
  try {
    const data = await fsAwait.readFile(filePath);
    console.log(chalk.bgGreen.black("########## Promise based file #########"));
    console.log(data.toString());
  } catch (error) {
    console.log(error);
  }
}
readData();

// ---------------- mkdir + async file ----------------
async function createTempFile() {
  try {
    const tmpDir = os.tmpdir();
    const uploadsDir = path.join(tmpDir, "uploads");
    await fsAwait.mkdir(uploadsDir, { recursive: true });
    const filePath = path.join(uploadsDir, "data.json");

    // nextTick runs before Promise resolution
    process.nextTick(() =>
      console.log(chalk.bgGreen.black("############### mkdir file ############"))
    );

    await fsAwait.writeFile(filePath, JSON.stringify({ name: "dullat" }));

    // setImmediate runs in check phase after I/O callbacks
    setImmediate(() => console.log("File created at:", filePath));
  } catch (error) {
    console.log(error);
  }
}

createTempFile();
```

---

# **Expected Output**

```
############### Sync file ############
hi this is me, dullat jatt...
############### mkdir file ############   <- from nextTick
############### Async file ############
hi this is me, dullat jatt...
appending this text..
########## Promise based file #########
hi this is me, dullat jatt...
appending this text..
File created at: /tmp/uploads/data.json  <- from setImmediate
```

---

# **Step-by-Step Execution Analysis**

### 1ï¸âƒ£ Synchronous Code

```js
fs.writeFileSync(filePath, ...)
const data = fs.readFileSync(filePath, ...)
```

- Runs immediately on **main stack**
    
- Blocks thread until done
    
- âœ… Logs `"############### Sync file ############"` first
    
- âœ… Logs `"hi this is me, dullat jatt..."` next
    

---

### 2ï¸âƒ£ `fs.readFile` (callback async)

```js
fs.readFile(filePath, (err, data) => ...)
```

- Sent to **libuv thread pool**
    
- Callback runs **later**, in I/O callback phase
    
- Appears **after nextTick** and current synchronous code
    

---

### 3ï¸âƒ£ Promise-based `readData()`

```js
await fsAwait.readFile(filePath)
```

- Function EC created â†’ pushed to stack
    
- `await` â†’ pauses EC â†’ EC popped from stack
    
- I/O happens in libuv thread pool
    
- When done â†’ promise resolves â†’ microtask scheduled â†’ EC resumed
    
- âœ… Logs `"########## Promise based file #########"` after async callback (timing may vary slightly)
    

---

### 4ï¸âƒ£ `createTempFile()`

```js
process.nextTick(() => ...)
await fsAwait.writeFile(...)
setImmediate(() => ...)
```

- EC created â†’ pushed to stack
    
- Hits `process.nextTick()` â†’ **scheduled immediately** â†’ runs **before Promise resolution**
    
    - âœ… `"############### mkdir file ############"` prints
        
- Hits `await writeFile()` â†’ pauses EC â†’ EC popped
    
- Main stack continues
    
- After file is written â†’ promise resolves â†’ EC resumes
    
- `setImmediate()` â†’ runs in **check phase** after I/O callbacks
    
    - âœ… `"File created at: /tmp/uploads/data.json"` prints last
        

---

### 5ï¸âƒ£ Why Logs Interleave

- `readData()` and `fs.readFile()` start nearly simultaneously
    
- I/O timing + microtasks cause `"Async file"` and `"Promise file"` logs to appear **between nextTick and setImmediate logs**
    
- **nextTick and setImmediate only control order inside `createTempFile()`**, not across separate async functions
    

---

# **Execution Context / Stack Insights**

- Each function has its **own execution context (EC)** â†’ true in Node & browser
    
- **Async functions donâ€™t create new threads**
    
- `await` **pauses EC** â†’ stack is free â†’ resumes later in microtask
    
- All functions share **single call stack / event loop**
    
- Only FS/network I/O run in **parallel threads** (libuv)
    

---

# **Mental Model (Backend Dev View)**

```
Main Stack:
[Sync code runs]
 â†“
[Async FS / Promise functions start]
 â†“
EC paused at await â†’ stack free
 â†“
nextTick queue runs (higher priority)
 â†“
Microtasks run (Promise resolves)
 â†“
I/O callbacks run
 â†“
setImmediate runs in check phase
```

- `nextTick` â†’ always first after sync code
    
- `await` â†’ microtask queue
    
- `setImmediate` â†’ check phase
    
- Multiple async functions â†’ logs interleave based on I/O completion
    

---

# âœ… Takeaways

1. `fs/promises + async/await` â†’ modern, production-ready
    
2. `process.nextTick()` â†’ runs **before** any microtasks
    
3. `setImmediate()` â†’ runs after I/O callbacks
    
4. Multiple async functions â†’ completion order depends on **I/O timing**
    
5. Execution context is **paused, not separate thread**
    
6. Sync FS â†’ blocks everything â†’ only safe for scripts, not servers
    
7. Always use `path.join()` + `{ recursive: true }` for directories
    

---

This note now captures your **exact example**, all console logs, **event loop phases**, **execution context**, and **async behavior**.

---

You can learn more about these, although you already did:

- **Call stack**
    
- **Execution contexts**
    
- **Microtasks**
    
- **nextTick / setImmediate**
    
- **FS I/O phases**
