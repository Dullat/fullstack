This will cover everything from environment variables to memory, signals, and async scheduling.

---

# üì¶ Node.js `process` Module

- `process` is a **global object** ‚Äî you **do not need to `require()` it**.
    
- It represents the **current Node.js process**.
    
- It provides information about:
    
    - The environment
        
    - Execution path
        
    - Memory & CPU
        
    - CLI arguments
        
    - Signals (e.g., Ctrl+C)
        
    - Event loop hooks
        

---

# 1Ô∏è‚É£ Process Info

```js
console.log("Process ID:", process.pid);        // PID of current process
console.log("Parent PID:", process.ppid);      // Parent process ID
console.log("Node version:", process.version); // e.g., v20.0.0
console.log("Node exec path:", process.execPath);
console.log("Current working dir:", process.cwd());
console.log("Script filename:", __filename);
console.log("Script dirname:", __dirname);
```

**Use case:** debugging, logging, or monitoring processes in production.

---

# 2Ô∏è‚É£ Environment Variables (`process.env`)

```js
console.log(process.env.NODE_ENV); // 'development' or 'production'
console.log(process.env.PATH);     // system PATH
```

**Setting a variable**:

```bash
NODE_ENV=production node app.js
```

**In code**:

```js
const PORT = process.env.PORT || 3000;
console.log(`Server running on port ${PORT}`);
```

> Real-world: **configure servers without hardcoding values**.

---

# 3Ô∏è‚É£ Command-Line Arguments (`process.argv`)

```js
console.log(process.argv);
```

Example:

```bash
node app.js hello world
```

Output:

```js
['/usr/bin/node', '/path/to/app.js', 'hello', 'world']
```

**Use case:** build CLI tools.

```js
const [,, firstArg, secondArg] = process.argv;
console.log(firstArg, secondArg); // hello world
```

---

# 4Ô∏è‚É£ Exiting the Process (`process.exit()`)

```js
process.exit(0); // success
process.exit(1); // error
```

> `0` = success, non-zero = failure (convention).

**Real-world:** terminate process after error or signal handling.

---

# 5Ô∏è‚É£ Signals and Graceful Shutdown

Node can listen to OS signals like `SIGINT` (Ctrl+C) and `SIGTERM`.

```js
process.on("SIGINT", () => {
  console.log("Ctrl+C detected. Cleaning up...");
  process.exit(0);
});

process.on("SIGTERM", () => {
  console.log("Process terminated gracefully.");
});
```

> Critical for **servers and Docker containers** to clean up DB connections.

---

# 6Ô∏è‚É£ Process Events

Node emits events on `process`:

- `exit` ‚Üí before process ends
    
- `beforeExit` ‚Üí right before exit if no work left
    
- `uncaughtException` ‚Üí unhandled exceptions
    
- `warning` ‚Üí process warnings
    

```js
process.on("exit", (code) => {
  console.log(`Process exiting with code ${code}`);
});

process.on("beforeExit", () => {
  console.log("Process has no more work, about to exit");
});

process.on("uncaughtException", (err) => {
  console.error("Unhandled error:", err);
  process.exit(1);
});
```

> **Real-world:** prevent crashes, log errors, or cleanup resources.

---

# 7Ô∏è‚É£ Memory Usage (`process.memoryUsage()`)

```js
console.log(process.memoryUsage());
```

Example output:

```js
{
  rss: 21299200,
  heapTotal: 5744640,
  heapUsed: 3300248,
  external: 1200120,
  arrayBuffers: 98712
}
```

- `rss` ‚Üí resident set size (total memory allocated for process)
    
- `heapTotal` ‚Üí total V8 heap size
    
- `heapUsed` ‚Üí actual used heap
    
- `external` ‚Üí C++ objects bound to JS
    
- `arrayBuffers` ‚Üí memory used by buffers
    

**Real-world:** monitoring memory leaks in servers or scripts.

---

# 8Ô∏è‚É£ CPU Usage (`process.cpuUsage()`)

```js
console.log(process.cpuUsage());
```

Returns microseconds:

```js
{ user: 123456, system: 654321 }
```

> Useful for profiling CPU-heavy scripts.

---

# 9Ô∏è‚É£ Asynchronous Hooks

### `process.nextTick()`

- Executes **before the event loop continues**.
    
- Highest priority async callback.
    

```js
console.log("start");

process.nextTick(() => console.log("nextTick callback"));

console.log("end");
```

**Output:**

```
start
end
nextTick callback
```

**Use case:** defer execution but **before I/O callbacks**.

---

### `setImmediate()`

- Executes on the **check phase of event loop** (after I/O).
    
- Lower priority than `process.nextTick`.
    

```js
console.log("start");

setImmediate(() => console.log("setImmediate callback"));

console.log("end");
```

**Output:**

```
start
end
setImmediate callback
```

> Difference: `nextTick` always runs **before I/O callbacks**, `setImmediate` runs **after I/O phase**.

---

# üîü High-Resolution Timer (`process.hrtime()`)

```js
const start = process.hrtime();
// some heavy work
const end = process.hrtime(start);
console.log(`Execution time: ${end[0]}s and ${end[1]/1e6}ms`);
```

> Use for performance profiling of critical code.

---

# 1Ô∏è‚É£1Ô∏è‚É£ Standard Input/Output

```js
process.stdout.write("Hello ");
process.stdout.write("World\n");

process.stdin.on("data", (data) => {
  console.log("You typed:", data.toString());
});
```

> Build CLI tools without external packages.

---

# 1Ô∏è‚É£2Ô∏è‚É£ Resource Limits

```js
console.log("Max listeners:", process.getMaxListeners());
process.setMaxListeners(20); // prevent memory leak warnings
```

> Useful for event-heavy applications.

---

# üéØ Real-World Example: Graceful Web Server with Process Module

```js
const http = require("http");

const server = http.createServer((req, res) => {
  res.end("Hello World");
});

server.listen(3000, () => console.log("Server started"));

const shutdown = () => {
  console.log("Cleaning up before shutdown...");
  server.close(() => process.exit(0));
};

process.on("SIGINT", shutdown);
process.on("SIGTERM", shutdown);
process.on("uncaughtException", (err) => {
  console.error("Unhandled error", err);
  shutdown();
});
```

> This ensures **no requests are lost** and the server exits gracefully.

---

# ‚úÖ Key Takeaways

1. `process` = Node process info + control + events.
    
2. **Environment variables** ‚Üí for configs.
    
3. **Signals & events** ‚Üí for graceful shutdown.
    
4. **Memory/CPU usage** ‚Üí for monitoring and debugging.
    
5. **Async hooks** ‚Üí `nextTick` vs `setImmediate` for advanced scheduling.
    
6. **stdin/stdout** ‚Üí build CLI tools.
    
7. **High-resolution timers** ‚Üí measure code performance.
    

---

üí° Mental Model:

> `process` = **Node‚Äôs window into the OS and runtime**, giving you control, info, and hooks into your script‚Äôs lifecycle.

---

If you want, next I can do a **complete ‚Äúcore modules cheat sheet‚Äù** with:

- `fs`, `path`, `http`, `url`, `os`, `events`, `crypto`, `stream`, **all in one place**
    
- With **examples and advanced tips**
    

This would give you a **full Node built-in toolkit mastery**.

Do you want me to do that?