
ðŸ‘‰ **Shallow copy does NOT â€œbreakâ€ on these.**  
ðŸ‘‰ **`JSON.parse(JSON.stringify())` breaks on these.**

Shallow copy just **shares references**.  
JSON serialization literally **canâ€™t represent certain JS things**, so they get lost or mangled.

Now letâ€™s go through each item and explain **exactly why** it breaks â€” no hand-waving.

---

## 1ï¸âƒ£ Functions âŒ

### What happens

```js
const obj = {
  sayHi() {
    console.log("hi");
  }
};

JSON.parse(JSON.stringify(obj));
// {}
```

### Why it breaks

JSON is a **data format**, not a programming language.

JSON supports:

- strings
    
- numbers
    
- booleans
    
- arrays
    
- objects
    
- null
    

It **does NOT support executable code**.

So when `JSON.stringify()` sees a function:

- it says: â€œI have no idea how to turn this into textâ€
    
- and **silently removes it**
    

ðŸ§  Think of JSON as a _shipping box_ â€” you can ship data, not behavior.

---

## 2ï¸âƒ£ `undefined` âŒ

### What happens

```js
JSON.stringify({ a: undefined });
// "{}"

JSON.stringify([undefined]);
// "[null]"
```

### Why it breaks

JSON has **no `undefined` value**.

So:

- object properties â†’ **dropped**
    
- array items â†’ replaced with `null` (to keep indexes intact)
    

This isnâ€™t random â€” itâ€™s following the JSON spec.

---

## 3ï¸âƒ£ `Date` âŒ

### What happens

```js
const obj = { now: new Date() };

const copy = JSON.parse(JSON.stringify(obj));

console.log(copy.now);        // "2026-02-06T10:30:00.000Z"
console.log(copy.now instanceof Date); // false
```

### Why it breaks

A `Date` is actually:

```js
typeof new Date() === "object"
```

When stringified:

- JS calls `.toJSON()`
    
- which turns it into an **ISO string**
    

JSON has **no Date type**, so on parse:

- you get a **string**, not a `Date` object
    

ðŸ§  The _information_ survives, but the _type_ is gone.

---

## 4ï¸âƒ£ `Map` / `Set` âŒ

### What happens

```js
const obj = {
  map: new Map([["a", 1]]),
  set: new Set([1, 2])
};

JSON.parse(JSON.stringify(obj));
// { map: {}, set: {} }
```

### Why it breaks

`Map` and `Set` are:

- iterable
    
- **not plain objects**
    
- have internal slots JSON canâ€™t see
    

JSON only serializes:

- objectâ€™s **own enumerable string keys**
    

`Map` and `Set` store data internally, not as `{ key: value }`, so JSON sees:

```js
{}
```

ðŸ’¥ Data never even makes it into the JSON string.

---

## 5ï¸âƒ£ Circular References âŒðŸ’¥

### What happens

```js
const obj = {};
obj.self = obj;

JSON.stringify(obj);
// âŒ TypeError: Converting circular structure to JSON
```

### Why it breaks

JSON is a **tree structure**.  
Circular references create a **graph**.

Example:

```txt
obj â†’ self â†’ obj â†’ self â†’ obj â†’ ...
```

JSON.stringify would loop forever, so JS **throws an error instead**.

ðŸ§  There is no syntax in JSON for â€œthis points back to something earlierâ€.

---

## ðŸ§© Why `structuredClone()` works

```js
structuredClone({
  fn: () => {},
  date: new Date(),
  map: new Map(),
  set: new Set(),
  circular: null
});
```

Because:

- it works at the **engine level**
    
- copies memory structures directly
    
- preserves types
    
- handles circular refs safely
    

Itâ€™s not converting to text â€” itâ€™s **actually cloning objects**.

---

## ðŸ§  Final mental model (this is the key)

|Technique|How it works|Result|
|---|---|---|
|Shallow copy|Copies references|Shared nested data|
|JSON clone|Converts to text|Loses non-JSON data|
|structuredClone|Copies memory|True deep copy|

---
