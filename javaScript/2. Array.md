

---

## ğŸ”¥ Trap #1: `splice` vs `slice` (the classic)

```js
const arr = [1, 2, 3];

arr.slice(1);
console.log(arr); // â“ [1, 2, 3]

arr.splice(1);
console.log(arr); // â— [1]
```

ğŸ‘‰ People expect both to â€œcutâ€
ğŸ‘‰ `splice` **mutates**, `slice` doesnâ€™t

---

## ğŸ”¥ Trap #2: `slice(-1)` vs `splice(-1)`

```js
const arr = [1, 2, 3];

arr.slice(-1);   // [3]
arr.splice(-1);  // removes [3], arr becomes [1, 2]
```

Same argument. Totally different effect.

---

## ğŸ”¥ Trap #3: `splice(0, -1)` removes NOTHING

```js
const arr = [1, 2, 3];

arr.splice(0, -1);
console.log(arr); // [1, 2, 3]
```

Why?

* `deleteCount < 0` â†’ treated as `0`
* So no deletion happens

Interviewers *love* this one.

---

## ğŸ”¥ Trap #4: Off-by-one with `slice`

```js
const arr = [10, 20, 30, 40];

arr.slice(1, 3); // [20, 30]
```

Why not 40?

* `end` index is **exclusive**

Mnemonic:

> `slice(start, end)` â†’ **end is a wall, not a door**

---

## ğŸ”¥ Trap #5: Thinking `slice()` deep copies

```js
const arr = [{ x: 1 }, { x: 2 }];
const copy = arr.slice();

copy[0].x = 999;

console.log(arr[0].x); // ğŸ˜¬ 999
```

`slice` does a **shallow copy**, not deep.

---

## ğŸ”¥ Trap #6: Mutating while looping

```js
const arr = [1, 2, 3, 4];

for (let i = 0; i < arr.length; i++) {
  if (arr[i] % 2 === 0) {
    arr.splice(i, 1);
  }
}
```

Result?

```js
[1, 3, 4] // âŒ 4 was skipped
```

Why?

* `splice` shifts indexes
* Loop counter keeps going

âœ… Safer:

```js
for (let i = arr.length - 1; i >= 0; i--) {
  if (arr[i] % 2 === 0) arr.splice(i, 1);
}
```

or better:

```js
const filtered = arr.filter(n => n % 2 !== 0);
```

---

## ğŸ”¥ Trap #7: Expecting `splice` to return the array

```js
const arr = [1, 2, 3];

const result = arr.splice(1, 1);

console.log(result); // [2]
console.log(arr);    // [1, 3]
```

`splice` returns **removed items**, not the updated array.

---

## ğŸ”¥ Trap #8: Modern fix â€” `at(-1)`

People write:

```js
arr[arr.length - 1];
```

Now:

```js
arr.at(-1);
```

Works on:

* arrays
* strings
* typed arrays

Cleaner. Safer. Interview brownie points ğŸª

---

## ğŸ§  Interview-safe rules

* **Need last element?** â†’ `arr.at(-1)`
* **Need copy?** â†’ `slice()`
* **Need mutation?** â†’ `splice()` (carefully)
* **Removing items?** â†’ prefer `filter()`

If you want, I can:

* throw **real interview questions**
* show **React bugs caused by splice**
* explain **why splice exists at all**
* compare **slice vs spread vs structuredClone**

Just say the word ğŸ‘€
