
In JavaScript,

**prototypes** are ==the mechanism that allows objects to inherit properties and methods from one another==. Unlike class-based languages like Java, JavaScript is **prototype-based**, meaning inheritance happens through a chain of objects.Â 

1. Key Concepts

- **The Prototype Chain:** Every object has a hidden property (often called `[[Prototype]]`) that points to another object. When you try to access a property that doesn't exist on an object, JavaScript automatically looks for it in its prototype, then the prototype's prototype, and so on until it reaches `null`.
- **Prototype vs. `__proto__`:**
    - **`prototype`**: A property found on constructor functions used to define methods shared by all instances.
    - **`__proto__`**: A (now deprecated/legacy) accessor property on instances that points to their constructor's `prototype`. Use the [Object.getPrototypeOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf) method instead.
- **Memory Efficiency:** Instead of duplicating methods for every instance, you define them once on the prototype, and all instances share that single reference.Â 

2. Basic Example: Constructor Functions

This is the "classic" way to use prototypes for shared behavior.

javascript

```
function Dog(name) {
  this.name = name; // Own property
}

// Adding a method to the prototype
Dog.prototype.bark = function() {
  console.log(`${this.name} says woof!`);
};

const fido = new Dog("Fido");
fido.bark(); // "Fido says woof!"
```

Use code with caution.

3. Modern Alternatives

- **`Object.create()`**: Creates a new object with a specified prototype object.
    
    javascript
    
    ```
    const animal = { eat: true };
    const rabbit = Object.create(animal);
    console.log(rabbit.eat); // true (inherited)
    ```
    
    Use code with caution.
    
- **ES6 Classes**: Modern classes are essentially "syntactic sugar" over the prototype system. Methods defined in a class are automatically added to the prototype.Â 

4. Important Considerations

- **Shadowing**: If an object and its prototype have a property with the same name, the object's "own" property is used first; this is called **shadowing**.
- **Native Prototypes**: You can technically extend built-in objects (like `Array.prototype`), but this is considered **bad practice** (monkey patching) as it can lead to conflicts and security risks like Prototype Pollution.
- **Object.create(null)**: You can create a "pure" object with no prototype at all, which is useful for data dictionaries that shouldn't inherit methods like `toString()`.Â 


---

# JavaScript Prototypes â€” Complete Mental Model

---

## 1ï¸âƒ£ What `[[Prototype]]` actually is

`[[Prototype]]` (double brackets) is **an internal, hidden link** that **every JavaScript object has**.

- It points to **another object**
    
- You **cannot access it directly**
    
- The double brackets mean: _â€œthis is internal to the JS engineâ€_
    

Conceptually:

```
obj  â”€â”€â–¶  [[Prototype]]  â”€â”€â–¶  another object
```

This link is what makes **inheritance** work in JavaScript.

---

## 2ï¸âƒ£ Why `[[Prototype]]` exists (the lookup rule)

When you do:

```js
obj.sayHi()
```

JavaScript does **property lookup**, not magic:

1. Check `obj` itself
    
2. If not found â†’ check `obj.[[Prototype]]`
    
3. If not found â†’ check `obj.[[Prototype]].[[Prototype]]`
    
4. Keep going
    
5. Stop at `null` â†’ throw error
    

This chain is called the **prototype chain**.

---

## 3ï¸âƒ£ How we interact with `[[Prototype]]`

We canâ€™t touch it directly, but JS gives us **controlled access**:

### `__proto__` (legacy but common)

- Getter/setter for `[[Prototype]]`
    
- Exists on **all objects**
    

```js
obj.__proto__ === Object.prototype
```

### `Object.getPrototypeOf(obj)` (recommended)

- Clean, modern, explicit
    

### `Object.setPrototypeOf(obj, proto)` (slow, avoid in hot paths)

---

## 4ï¸âƒ£ The most important rule (lock this in ðŸ”’)

> **An objectâ€™s `[[Prototype]]` points to the prototype of whatever created it**

This single sentence explains _everything_.

---

## 5ï¸âƒ£ Plain objects `{}`

```js
const obj = {};
```

What happens behind the scenes:

```
obj
 â””â”€â”€ [[Prototype]] â†’ Object.prototype
                        â””â”€â”€ [[Prototype]] â†’ null
```

So:

```js
Object.getPrototypeOf(obj) === Object.prototype // true
```

â— **Important**  
This does **NOT** point to the global object (`window` / `global`).

- Global object â†’ where globals live
    
- `Object.prototype` â†’ shared behavior for objects
    

Different things.

---

## 6ï¸âƒ£ What `Object.prototype` really is

`Object.prototype` is:

- A **normal JavaScript object**
    
- The **default parent** of almost everything
    
- The **top of the prototype chain**
    

It exists because JS needed a place for **shared behavior**:

- `toString`
    
- `hasOwnProperty`
    
- `valueOf`
    
- `isPrototypeOf`
    
- etc.
    

Conceptually:

```js
Object.prototype = {
  constructor: Object,
  toString() {},
  valueOf() {},
  hasOwnProperty() {},
  isPrototypeOf() {},
};
```

And above it:

```js
Object.getPrototypeOf(Object.prototype); // null
```

Thatâ€™s the end of the chain ðŸ”ï¸

---

## 7ï¸âƒ£ Why objects â€œhaveâ€ methods they never defined

```js
const obj = { a: 1 };
obj.toString();
```

JS thinks:

1. Does `obj` have `toString`? âŒ
    
2. Check `Object.prototype` âœ…
    
3. Call it with `this = obj`
    

So objects donâ€™t _own_ these methods â€” they **borrow** them.

---

## 8ï¸âƒ£ Arrays, functions, dates â€” why they also work

Everything eventually ends at `Object.prototype`:

```js
[] â†’ Array.prototype â†’ Object.prototype â†’ null
() => {} â†’ Function.prototype â†’ Object.prototype â†’ null
new Date() â†’ Date.prototype â†’ Object.prototype â†’ null
```

Thatâ€™s why this works:

```js
[].toString();
(() => {}).toString();
```

---

## 9ï¸âƒ£ `prototype` vs `[[Prototype]]` (THE BIG CONFUSION)

### `[[Prototype]]`

- Exists on **objects**
    
- Hidden internal link
    
- Answers: _â€œWhere do I look next?â€_
    

### `.prototype`

- Exists on **constructor functions**
    
- Used only when calling `new`
    
- Answers: _â€œWhat should instances inherit from?â€_
    

---

## ðŸ” How `new` connects them

```js
function Person(name) {
  this.name = name;
}

Person.prototype.sayHi = function () {
  return "hi";
};

const p = new Person("Alex");
```

What happens:

```
p.[[Prototype]] === Person.prototype  // true
```

Prototype chain:

```
p â†’ Person.prototype â†’ Object.prototype â†’ null
```

---

## 10ï¸âƒ£ Object creation methods and their prototypes

### Object literal

```js
const a = {};
```

```
a.[[Prototype]] â†’ Object.prototype
```

### Constructor function

```js
const p = new Person();
```

```
p.[[Prototype]] â†’ Person.prototype
```

### `Object.create(proto)`

```js
const x = Object.create(null);
```

```
x.[[Prototype]] â†’ null
```

(no prototype chain at all ðŸ˜®)

---

## 11ï¸âƒ£ `Object.create(obj)` example

```js
const base = { greet() {} };
const child = Object.create(base);
```

Chain:

```
child â†’ base â†’ Object.prototype â†’ null
```

So:

```js
child.greet(); // found on base
```

---

## 12ï¸âƒ£ Modifying `Object.prototype` (âš ï¸ dangerous but educational)

```js
Object.prototype.sayHi = () => "hi";
```

Now **everything** can do this:

```js
({}).sayHi();
[].sayHi();
(() => {}).sayHi();
```

Why?

```
everything â†’ ... â†’ Object.prototype
```

âš ï¸ **Real-world rule**  
Never do this in production â€” it breaks libraries, loops, and assumptions.

---

## 13ï¸âƒ£ `.prototype` exists where?

âœ… Constructor functions:

- `Object.prototype`
    
- `Array.prototype`
    
- `Function.prototype`
    
- `Person.prototype`
    

âŒ Plain objects:

```js
({}).prototype // undefined
```

---

## 14ï¸âƒ£ Critical gotcha: arrow functions on prototypes âŒ

âŒ Wrong:

```js
Person.prototype.sayHi = () => {
  return this.name;
};
```

Arrow functions:

- Do **not** have their own `this`
    
- `this` will NOT be the instance
    

âœ… Correct:

```js
Person.prototype.sayHi = function () {
  return this.name;
};
```

This is a **huge interview + real-world gotcha**.

---

## 15ï¸âƒ£ One mental model to remember forever

- `[[Prototype]]` â†’ **â€œWhere do I look next?â€**
    
- `.prototype` â†’ **â€œWhat will instances link to?â€**
    
- `__proto__` â†’ **â€œLet me peek at the hidden link.â€**
    
- `Object.prototype` â†’ **â€œFinal fallback for almost everything.â€**
    

---

## 16ï¸âƒ£ Final truth (the click sentence)

> **JavaScript inheritance is just objects linked to other objects via `[[Prototype]]`.**

No classes. No magic. Just links.

---

# Funs array's prototype ?? why its here

---

## Short anchor answer (then we expand)

> **Yes. Arrays and functions ALSO ultimately inherit from `Object.prototype`.**  
> But they do it **through their own prototypes first**.

Nothing (except `Object.prototype`) skips `Object.prototype`.

---

## 1ï¸âƒ£ Arrays: what is their prototype chain?

```js
const arr = [];
```

What JS actually builds:

```
arr
 â””â”€â”€ [[Prototype]] â†’ Array.prototype
                        â””â”€â”€ [[Prototype]] â†’ Object.prototype
                                                â””â”€â”€ [[Prototype]] â†’ null
```

So:

```js
Object.getPrototypeOf(arr) === Array.prototype        // true
Object.getPrototypeOf(Array.prototype) === Object.prototype // true
```

### Why this matters

- `push`, `pop`, `map` â†’ from `Array.prototype`
    
- `toString`, `hasOwnProperty` â†’ from `Object.prototype`
    

Thatâ€™s why:

```js
arr.push(1);        // array behavior
arr.toString();    // object behavior
```

---

## 2ï¸âƒ£ Functions: yes, they also inherit from `Object.prototype`

Functions are **callable objects**.

```js
function fn() {}
```

Prototype chain:

```
fn
 â””â”€â”€ [[Prototype]] â†’ Function.prototype
                        â””â”€â”€ [[Prototype]] â†’ Object.prototype
                                                â””â”€â”€ null
```

Check it yourself:

```js
Object.getPrototypeOf(fn) === Function.prototype      // true
Object.getPrototypeOf(Function.prototype) === Object.prototype // true
```

### Why this matters

Functions can:

```js
fn.call();
fn.bind();
fn.apply();   // from Function.prototype

fn.toString(); // from Object.prototype
```

---

## 3ï¸âƒ£ VERY important: functions have TWO prototype-related things

This is where people get lost ðŸ‘‡

### (A) `fn.[[Prototype]]` â†’ how the function itself works

```js
fn.__proto__ === Function.prototype
```

This gives functions:

- `call`
    
- `apply`
    
- `bind`
    

---

### (B) `fn.prototype` â†’ used ONLY when `new fn()` is called

```js
function Person() {}

Person.prototype.sayHi = function () {};
```

This object becomes the **`[[Prototype]]` of instances**:

```js
const p = new Person();

p.__proto__ === Person.prototype // true
```

So:

|Thing|Purpose|
|---|---|
|`fn.__proto__`|how the function behaves|
|`fn.prototype`|what instances inherit|

ðŸ”¥ This distinction is _core JS understanding_.

---

## 4ï¸âƒ£ Arrays also have `.prototype` â€” but not how you think

```js
Array.prototype
```

This is the object that **array instances inherit from**.

```js
const a = [];
a.__proto__ === Array.prototype // true
```

And then:

```js
Array.prototype.__proto__ === Object.prototype // true
```

So arrays do **not** skip `Object.prototype`.

---

## 5ï¸âƒ£ Does _everything_ inherit from `Object.prototype`?

Almost everything.

### The only exception:

```js
const naked = Object.create(null);
```

```
naked â†’ null
```

No:

- `toString`
    
- `hasOwnProperty`
    
- prototype chain at all
    

This proves inheritance is **opt-in via linkage**, not magic.

---

## 6ï¸âƒ£ Why JS was designed this way (philosophy)

JavaScript doesnâ€™t have classical inheritance.

Instead it has:

> **Objects linked to other objects**

Arrays and functions are **specialized objects**, not separate creatures.

Thatâ€™s why:

- arrays are objects
    
- functions are objects
    
- objects are objects ðŸ˜„
    

Just with **different prototype chains**.

---

## 7ï¸âƒ£ Mental model that never breaks

Think like this:

> Every value asks:  
> **â€œWho should I borrow behavior from?â€**

|Value|First prototype|Then|
|---|---|---|
|`{}`|Object.prototype|null|
|`[]`|Array.prototype|Object.prototype|
|`fn()`|Function.prototype|Object.prototype|
|`new Person()`|Person.prototype|Object.prototype|

---

## 8ï¸âƒ£ One-line truth (write this on your wall)

> **In JavaScript, specialization comes first, but `Object.prototype` is always the final fallback.**

---

Understand next: 
    
- why `typeof function === "function"` but itâ€™s still an object
    
- walk through _exactly_ what happens when JS executes `arr.map()` step by step

## Understanding

You already understand:

> `__proto__` â†’ pointer to parent (the object you inherit from)

Now letâ€™s answer clearly:

# What REALLY is `prototype`?

### ðŸ‘‰ `prototype` is just a normal object that lives on a function.

Thatâ€™s it.

It is **not** the parent.  
It is the object that _will become the parent_ of instances created with `new`.

---

# Step 1 â€” Functions are Objects

In JavaScript:

```js
function User() {}
```

`User` is an object.

And JS automatically gives it a property:

```js
User.prototype
```

Letâ€™s inspect it:

```js
console.log(User.prototype)
```

Output:

```js
{
  constructor: User
}
```

Thatâ€™s the default content.

---

# Step 2 â€” What does `prototype` contain?

By default:

```js
User.prototype = {
  constructor: User
}
```

Thatâ€™s it.

When you add:

```js
User.prototype.sayHi = function() {}
```

Now it contains:

```js
{
  constructor: User,
  sayHi: function() {}
}
```

So:

> `prototype` contains methods and properties that will be shared by all instances.

---

# Step 3 â€” What happens during `new`?

When you do:

```js
const u1 = new User()
```

JS does internally:

```js
const obj = {}
obj.__proto__ = User.prototype
User.call(obj)
return obj
```

ðŸ”¥ IMPORTANT:

`prototype` becomes the value of `__proto__` for the new object.

So:

```js
u1.__proto__ === User.prototype  // true
```

---

# ðŸ”¥ The Big Mental Model

### `prototype` = blueprint object

### `__proto__` = actual link to that blueprint

---

# Visual Representation

```
User (function object)
   |
   |-- prototype  ---->  { constructor: User, sayHi: fn }
                                 â†‘
                                 |
                          u1.__proto__
                                 â†‘
                                 |
                                u1
```

---

# Key Truth

- `prototype` exists only on functions (constructor functions)
    
- `__proto__` exists on all objects
    
- `prototype` is used ONLY when you use `new`
    

---

# Super Important Distinction

This:

```js
User.prototype
```

is NOT the prototype of `User`.

THIS is the prototype of `User`:

```js
User.__proto__
```

And that equals:

```js
Function.prototype
```

Yes â€” functions are objects too ðŸ˜„

---

# Quick Summary

|Thing|What it is|
|---|---|
|`prototype`|Object stored on a function|
|`__proto__`|Internal link to another object|
|`new`|Connects instance `__proto__` to functionâ€™s `prototype`|

---

# Final Deep Insight

Think of it like this:

- `prototype` = storage box for shared methods
    
- `__proto__` = pointer to that storage box
    

---

If you want, I can now explain:

- Why `constructor` exists inside `prototype`
    
- What happens if you overwrite `User.prototype`
    
- How this works with `class`
    
- Or the full prototype chain from scratch (mind-blowing but clean)
