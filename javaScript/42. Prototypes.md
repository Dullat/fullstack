

---

# JavaScript Prototypes â€” Complete Mental Model

---

## 1ï¸âƒ£ What `[[Prototype]]` actually is

`[[Prototype]]` (double brackets) is **an internal, hidden link** that **every JavaScript object has**.

- It points to **another object**
    
- You **cannot access it directly**
    
- The double brackets mean: _â€œthis is internal to the JS engineâ€_
    

Conceptually:

```
obj  â”€â”€â–¶  [[Prototype]]  â”€â”€â–¶  another object
```

This link is what makes **inheritance** work in JavaScript.

---

## 2ï¸âƒ£ Why `[[Prototype]]` exists (the lookup rule)

When you do:

```js
obj.sayHi()
```

JavaScript does **property lookup**, not magic:

1. Check `obj` itself
    
2. If not found â†’ check `obj.[[Prototype]]`
    
3. If not found â†’ check `obj.[[Prototype]].[[Prototype]]`
    
4. Keep going
    
5. Stop at `null` â†’ throw error
    

This chain is called the **prototype chain**.

---

## 3ï¸âƒ£ How we interact with `[[Prototype]]`

We canâ€™t touch it directly, but JS gives us **controlled access**:

### `__proto__` (legacy but common)

- Getter/setter for `[[Prototype]]`
    
- Exists on **all objects**
    

```js
obj.__proto__ === Object.prototype
```

### `Object.getPrototypeOf(obj)` (recommended)

- Clean, modern, explicit
    

### `Object.setPrototypeOf(obj, proto)` (slow, avoid in hot paths)

---

## 4ï¸âƒ£ The most important rule (lock this in ðŸ”’)

> **An objectâ€™s `[[Prototype]]` points to the prototype of whatever created it**

This single sentence explains _everything_.

---

## 5ï¸âƒ£ Plain objects `{}`

```js
const obj = {};
```

What happens behind the scenes:

```
obj
 â””â”€â”€ [[Prototype]] â†’ Object.prototype
                        â””â”€â”€ [[Prototype]] â†’ null
```

So:

```js
Object.getPrototypeOf(obj) === Object.prototype // true
```

â— **Important**  
This does **NOT** point to the global object (`window` / `global`).

- Global object â†’ where globals live
    
- `Object.prototype` â†’ shared behavior for objects
    

Different things.

---

## 6ï¸âƒ£ What `Object.prototype` really is

`Object.prototype` is:

- A **normal JavaScript object**
    
- The **default parent** of almost everything
    
- The **top of the prototype chain**
    

It exists because JS needed a place for **shared behavior**:

- `toString`
    
- `hasOwnProperty`
    
- `valueOf`
    
- `isPrototypeOf`
    
- etc.
    

Conceptually:

```js
Object.prototype = {
  constructor: Object,
  toString() {},
  valueOf() {},
  hasOwnProperty() {},
  isPrototypeOf() {},
};
```

And above it:

```js
Object.getPrototypeOf(Object.prototype); // null
```

Thatâ€™s the end of the chain ðŸ”ï¸

---

## 7ï¸âƒ£ Why objects â€œhaveâ€ methods they never defined

```js
const obj = { a: 1 };
obj.toString();
```

JS thinks:

1. Does `obj` have `toString`? âŒ
    
2. Check `Object.prototype` âœ…
    
3. Call it with `this = obj`
    

So objects donâ€™t _own_ these methods â€” they **borrow** them.

---

## 8ï¸âƒ£ Arrays, functions, dates â€” why they also work

Everything eventually ends at `Object.prototype`:

```js
[] â†’ Array.prototype â†’ Object.prototype â†’ null
() => {} â†’ Function.prototype â†’ Object.prototype â†’ null
new Date() â†’ Date.prototype â†’ Object.prototype â†’ null
```

Thatâ€™s why this works:

```js
[].toString();
(() => {}).toString();
```

---

## 9ï¸âƒ£ `prototype` vs `[[Prototype]]` (THE BIG CONFUSION)

### `[[Prototype]]`

- Exists on **objects**
    
- Hidden internal link
    
- Answers: _â€œWhere do I look next?â€_
    

### `.prototype`

- Exists on **constructor functions**
    
- Used only when calling `new`
    
- Answers: _â€œWhat should instances inherit from?â€_
    

---

## ðŸ” How `new` connects them

```js
function Person(name) {
  this.name = name;
}

Person.prototype.sayHi = function () {
  return "hi";
};

const p = new Person("Alex");
```

What happens:

```
p.[[Prototype]] === Person.prototype  // true
```

Prototype chain:

```
p â†’ Person.prototype â†’ Object.prototype â†’ null
```

---

## 10ï¸âƒ£ Object creation methods and their prototypes

### Object literal

```js
const a = {};
```

```
a.[[Prototype]] â†’ Object.prototype
```

### Constructor function

```js
const p = new Person();
```

```
p.[[Prototype]] â†’ Person.prototype
```

### `Object.create(proto)`

```js
const x = Object.create(null);
```

```
x.[[Prototype]] â†’ null
```

(no prototype chain at all ðŸ˜®)

---

## 11ï¸âƒ£ `Object.create(obj)` example

```js
const base = { greet() {} };
const child = Object.create(base);
```

Chain:

```
child â†’ base â†’ Object.prototype â†’ null
```

So:

```js
child.greet(); // found on base
```

---

## 12ï¸âƒ£ Modifying `Object.prototype` (âš ï¸ dangerous but educational)

```js
Object.prototype.sayHi = () => "hi";
```

Now **everything** can do this:

```js
({}).sayHi();
[].sayHi();
(() => {}).sayHi();
```

Why?

```
everything â†’ ... â†’ Object.prototype
```

âš ï¸ **Real-world rule**  
Never do this in production â€” it breaks libraries, loops, and assumptions.

---

## 13ï¸âƒ£ `.prototype` exists where?

âœ… Constructor functions:

- `Object.prototype`
    
- `Array.prototype`
    
- `Function.prototype`
    
- `Person.prototype`
    

âŒ Plain objects:

```js
({}).prototype // undefined
```

---

## 14ï¸âƒ£ Critical gotcha: arrow functions on prototypes âŒ

âŒ Wrong:

```js
Person.prototype.sayHi = () => {
  return this.name;
};
```

Arrow functions:

- Do **not** have their own `this`
    
- `this` will NOT be the instance
    

âœ… Correct:

```js
Person.prototype.sayHi = function () {
  return this.name;
};
```

This is a **huge interview + real-world gotcha**.

---

## 15ï¸âƒ£ One mental model to remember forever

- `[[Prototype]]` â†’ **â€œWhere do I look next?â€**
    
- `.prototype` â†’ **â€œWhat will instances link to?â€**
    
- `__proto__` â†’ **â€œLet me peek at the hidden link.â€**
    
- `Object.prototype` â†’ **â€œFinal fallback for almost everything.â€**
    

---

## 16ï¸âƒ£ Final truth (the click sentence)

> **JavaScript inheritance is just objects linked to other objects via `[[Prototype]]`.**

No classes. No magic. Just links.

---

# Funs array's prototype ?? why its here

---

## Short anchor answer (then we expand)

> **Yes. Arrays and functions ALSO ultimately inherit from `Object.prototype`.**  
> But they do it **through their own prototypes first**.

Nothing (except `Object.prototype`) skips `Object.prototype`.

---

## 1ï¸âƒ£ Arrays: what is their prototype chain?

```js
const arr = [];
```

What JS actually builds:

```
arr
 â””â”€â”€ [[Prototype]] â†’ Array.prototype
                        â””â”€â”€ [[Prototype]] â†’ Object.prototype
                                                â””â”€â”€ [[Prototype]] â†’ null
```

So:

```js
Object.getPrototypeOf(arr) === Array.prototype        // true
Object.getPrototypeOf(Array.prototype) === Object.prototype // true
```

### Why this matters

- `push`, `pop`, `map` â†’ from `Array.prototype`
    
- `toString`, `hasOwnProperty` â†’ from `Object.prototype`
    

Thatâ€™s why:

```js
arr.push(1);        // array behavior
arr.toString();    // object behavior
```

---

## 2ï¸âƒ£ Functions: yes, they also inherit from `Object.prototype`

Functions are **callable objects**.

```js
function fn() {}
```

Prototype chain:

```
fn
 â””â”€â”€ [[Prototype]] â†’ Function.prototype
                        â””â”€â”€ [[Prototype]] â†’ Object.prototype
                                                â””â”€â”€ null
```

Check it yourself:

```js
Object.getPrototypeOf(fn) === Function.prototype      // true
Object.getPrototypeOf(Function.prototype) === Object.prototype // true
```

### Why this matters

Functions can:

```js
fn.call();
fn.bind();
fn.apply();   // from Function.prototype

fn.toString(); // from Object.prototype
```

---

## 3ï¸âƒ£ VERY important: functions have TWO prototype-related things

This is where people get lost ðŸ‘‡

### (A) `fn.[[Prototype]]` â†’ how the function itself works

```js
fn.__proto__ === Function.prototype
```

This gives functions:

- `call`
    
- `apply`
    
- `bind`
    

---

### (B) `fn.prototype` â†’ used ONLY when `new fn()` is called

```js
function Person() {}

Person.prototype.sayHi = function () {};
```

This object becomes the **`[[Prototype]]` of instances**:

```js
const p = new Person();

p.__proto__ === Person.prototype // true
```

So:

|Thing|Purpose|
|---|---|
|`fn.__proto__`|how the function behaves|
|`fn.prototype`|what instances inherit|

ðŸ”¥ This distinction is _core JS understanding_.

---

## 4ï¸âƒ£ Arrays also have `.prototype` â€” but not how you think

```js
Array.prototype
```

This is the object that **array instances inherit from**.

```js
const a = [];
a.__proto__ === Array.prototype // true
```

And then:

```js
Array.prototype.__proto__ === Object.prototype // true
```

So arrays do **not** skip `Object.prototype`.

---

## 5ï¸âƒ£ Does _everything_ inherit from `Object.prototype`?

Almost everything.

### The only exception:

```js
const naked = Object.create(null);
```

```
naked â†’ null
```

No:

- `toString`
    
- `hasOwnProperty`
    
- prototype chain at all
    

This proves inheritance is **opt-in via linkage**, not magic.

---

## 6ï¸âƒ£ Why JS was designed this way (philosophy)

JavaScript doesnâ€™t have classical inheritance.

Instead it has:

> **Objects linked to other objects**

Arrays and functions are **specialized objects**, not separate creatures.

Thatâ€™s why:

- arrays are objects
    
- functions are objects
    
- objects are objects ðŸ˜„
    

Just with **different prototype chains**.

---

## 7ï¸âƒ£ Mental model that never breaks

Think like this:

> Every value asks:  
> **â€œWho should I borrow behavior from?â€**

|Value|First prototype|Then|
|---|---|---|
|`{}`|Object.prototype|null|
|`[]`|Array.prototype|Object.prototype|
|`fn()`|Function.prototype|Object.prototype|
|`new Person()`|Person.prototype|Object.prototype|

---

## 8ï¸âƒ£ One-line truth (write this on your wall)

> **In JavaScript, specialization comes first, but `Object.prototype` is always the final fallback.**

---

Understand next: 
    
- why `typeof function === "function"` but itâ€™s still an object
    
- walk through _exactly_ what happens when JS executes `arr.map()` step by step
