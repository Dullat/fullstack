# **Complete Guide: Prototypal Inheritance vs Class-Based Inheritance**


---

## **PART 1: Understanding Prototypes First**

### **1.1 What is a Prototype?**

Every object in JavaScript has an internal link to another object called its **prototype**.

```javascript
const obj = {};
console.log(Object.getPrototypeOf(obj)); // Object.prototype
```

**The chain:**

```
obj → Object.prototype → null
```

When you access a property:

1. JavaScript checks `obj` itself
2. If not found, checks `obj`'s prototype
3. If not found, checks prototype's prototype
4. ... continues until `null`

---

### **1.2 Creating the Prototype Chain**

```javascript
const animal = {
    eats: true,
    walk() {
        console.log("Animal walks");
    }
};

const rabbit = {
    jumps: true
};

// Link rabbit's prototype to animal
Object.setPrototypeOf(rabbit, animal);

console.log(rabbit.jumps); // true (own property)
console.log(rabbit.eats);  // true (inherited from animal)
rabbit.walk();              // "Animal walks" (inherited)

// The chain:
// rabbit → animal → Object.prototype → null
```

**Check the chain:**

```javascript
console.log(Object.getPrototypeOf(rabbit) === animal); // true
console.log(Object.getPrototypeOf(animal) === Object.prototype); // true
console.log(Object.getPrototypeOf(Object.prototype)); // null
```

---

### **1.3 The `__proto__` Property (Deprecated)**

```javascript
console.log(rabbit.__proto__ === animal); // true
```

⚠️ **Don't use `__proto__`** in production code. Use:

- `Object.getPrototypeOf(obj)` to read
- `Object.setPrototypeOf(obj, proto)` to set
- `Object.create(proto)` to create with specific prototype

---

### **1.4 Own vs Inherited Properties**

```javascript
console.log(rabbit.hasOwnProperty('jumps')); // true
console.log(rabbit.hasOwnProperty('eats'));  // false (inherited)

// Loop through own properties only
for (let key in rabbit) {
    if (rabbit.hasOwnProperty(key)) {
        console.log(key); // Only "jumps"
    }
}

// Get all own properties
console.log(Object.keys(rabbit)); // ["jumps"]
console.log(Object.getOwnPropertyNames(rabbit)); // ["jumps"]
```

---

## **PART 2: Prototypal Inheritance (Pure Prototype Approach)**

### **2.1 Using `Object.create()`**

```javascript
const animal = {
    eats: true,
    walk() {
        console.log(`${this.name} walks`);
    }
};

// Create rabbit with animal as prototype
const rabbit = Object.create(animal);
rabbit.name = "White Rabbit";
rabbit.jumps = true;

rabbit.walk(); // "White Rabbit walks"
console.log(rabbit.eats); // true (inherited)
```

**What happens:**

```
rabbit (own: name, jumps)
  ↓
animal (own: eats, walk)
  ↓
Object.prototype
  ↓
null
```

---

### **2.2 Factory Pattern (Creating Multiple Objects)**

```javascript
const animalMethods = {
    eat() {
        console.log(`${this.name} is eating`);
    },
    sleep() {
        console.log(`${this.name} is sleeping`);
    }
};

function createAnimal(name, species) {
    const animal = Object.create(animalMethods);
    animal.name = name;
    animal.species = species;
    return animal;
}

const dog = createAnimal("Buddy", "Dog");
const cat = createAnimal("Whiskers", "Cat");

dog.eat(); // "Buddy is eating"
cat.eat(); // "Whiskers is eating"

// Both share the same methods (memory efficient)
console.log(dog.eat === cat.eat); // true
```

---

### **2.3 Inheritance with `Object.create()`**

```javascript
const animal = {
    init(name) {
        this.name = name;
        return this;
    },
    eat() {
        console.log(`${this.name} eats`);
    }
};

const rabbit = Object.create(animal);
rabbit.init = function(name) {
    animal.init.call(this, name); // Call parent init
    this.jumps = true;
    return this;
};
rabbit.jump = function() {
    console.log(`${this.name} jumps`);
};

const bunny = Object.create(rabbit).init("Bunny");
bunny.eat();  // "Bunny eats" (from animal)
bunny.jump(); // "Bunny jumps" (from rabbit)
```

**The chain:**

```
bunny → rabbit → animal → Object.prototype → null
```

---

## **PART 3: Constructor Functions (Old Class-Like Pattern)**

### **3.1 Basic Constructor**

```javascript
function Animal(name) {
    this.name = name;
}

// Add methods to prototype (shared across instances)
Animal.prototype.eat = function() {
    console.log(`${this.name} eats`);
};

const dog = new Animal("Buddy");
dog.eat(); // "Buddy eats"
```

**What `new` does:**

```javascript
// When you call: new Animal("Buddy")

// 1. Create empty object
const this = {};

// 2. Link to prototype
Object.setPrototypeOf(this, Animal.prototype);

// 3. Execute constructor
Animal.call(this, "Buddy");

// 4. Return this
return this;
```

---

### **3.2 The `prototype` Property**

**Every function has a `.prototype` property:**

```javascript
function Person() {}

console.log(Person.prototype); // { constructor: Person }
console.log(Person.prototype.constructor === Person); // true
```

**When you use `new`, the created object's prototype links to the function's `.prototype`:**

```javascript
const john = new Person();
console.log(Object.getPrototypeOf(john) === Person.prototype); // true
```

---

### **3.3 Adding Methods to Prototype**

```javascript
function Animal(name) {
    this.name = name;
}

// ✅ Good: Methods on prototype (shared)
Animal.prototype.eat = function() {
    console.log(`${this.name} eats`);
};

// ❌ Bad: Methods in constructor (duplicated for each instance)
function Animal(name) {
    this.name = name;
    this.eat = function() {
        console.log(`${this.name} eats`);
    };
}

const dog1 = new Animal("Buddy");
const dog2 = new Animal("Max");

console.log(dog1.eat === dog2.eat); // false (wasteful!)
```

---

### **3.4 Inheritance with Constructor Functions**

```javascript
// Parent constructor
function Animal(name) {
    this.name = name;
}

Animal.prototype.eat = function() {
    console.log(`${this.name} eats`);
};

// Child constructor
function Dog(name, breed) {
    Animal.call(this, name); // Call parent constructor
    this.breed = breed;
}

// Link prototypes
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog; // Fix constructor reference

Dog.prototype.bark = function() {
    console.log(`${this.name} barks`);
};

const buddy = new Dog("Buddy", "Golden Retriever");
buddy.eat();  // "Buddy eats" (inherited)
buddy.bark(); // "Buddy barks" (own method)
```

**The chain:**

```
buddy → Dog.prototype → Animal.prototype → Object.prototype → null
```

**Why `Dog.prototype.constructor = Dog`?**

```javascript
// Without fixing:
console.log(buddy.constructor); // Animal (wrong!)

// After fixing:
Dog.prototype.constructor = Dog;
console.log(buddy.constructor); // Dog (correct!)
```

---

## **PART 4: ES6 Classes (Syntactic Sugar)**

### **4.1 Basic Class**

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    eat() {
        console.log(`${this.name} eats`);
    }
}

const dog = new Animal("Buddy");
dog.eat(); // "Buddy eats"
```

**Under the hood, this is exactly:**

```javascript
function Animal(name) {
    this.name = name;
}

Animal.prototype.eat = function() {
    console.log(`${this.name} eats`);
};
```

---

### **4.2 Class Inheritance with `extends`**

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    eat() {
        console.log(`${this.name} eats`);
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // MUST call parent constructor first
        this.breed = breed;
    }
    
    bark() {
        console.log(`${this.name} barks`);
    }
}

const buddy = new Dog("Buddy", "Golden Retriever");
buddy.eat();  // "Buddy eats"
buddy.bark(); // "Buddy barks"
```

---

### **4.3 Method Overriding**

```javascript
class Animal {
    speak() {
        console.log("Animal makes a sound");
    }
}

class Dog extends Animal {
    speak() {
        console.log("Dog barks");
    }
}

const dog = new Dog();
dog.speak(); // "Dog barks" (overridden)
```

**Calling parent method with `super`:**

```javascript
class Dog extends Animal {
    speak() {
        super.speak(); // Call parent method
        console.log("Dog barks");
    }
}

const dog = new Dog();
dog.speak();
// Output:
// "Animal makes a sound"
// "Dog barks"
```

---

### **4.4 Static Methods**

**Belong to the class itself, not instances:**

```javascript
class MathUtils {
    static add(a, b) {
        return a + b;
    }
}

console.log(MathUtils.add(5, 3)); // 8

const util = new MathUtils();
// util.add(5, 3); // Error! add is not on instances
```

**Static method inheritance:**

```javascript
class Animal {
    static info() {
        console.log("Animals are living beings");
    }
}

class Dog extends Animal {}

Dog.info(); // "Animals are living beings" (inherited)
```

---

### **4.5 Getters and Setters**

```javascript
class Circle {
    constructor(radius) {
        this._radius = radius;
    }
    
    get diameter() {
        return this._radius * 2;
    }
    
    set diameter(value) {
        this._radius = value / 2;
    }
    
    get area() {
        return Math.PI * this._radius ** 2;
    }
}

const circle = new Circle(5);
console.log(circle.diameter); // 10 (getter)
console.log(circle.area);     // 78.54

circle.diameter = 20; // (setter)
console.log(circle._radius); // 10
```

---

### **4.6 Private Fields (ES2022)**

```javascript
class BankAccount {
    #balance = 0; // Private field
    
    deposit(amount) {
        this.#balance += amount;
    }
    
    getBalance() {
        return this.#balance;
    }
}

const account = new BankAccount();
account.deposit(100);
console.log(account.getBalance()); // 100
// console.log(account.#balance); // SyntaxError!
```

---

## **PART 5: Deep Dive into `instanceof`**

### **5.1 How `instanceof` Works**

Checks if `Constructor.prototype` exists anywhere in the object's prototype chain.

```javascript
class Animal {}
class Dog extends Animal {}

const dog = new Dog();

console.log(dog instanceof Dog);    // true
console.log(dog instanceof Animal); // true
console.log(dog instanceof Object); // true

// What it's checking:
// dog → Dog.prototype → Animal.prototype → Object.prototype → null
```

---

### **5.2 Manual Check**

```javascript
function myInstanceOf(obj, Constructor) {
    let proto = Object.getPrototypeOf(obj);
    
    while (proto !== null) {
        if (proto === Constructor.prototype) {
            return true;
        }
        proto = Object.getPrototypeOf(proto);
    }
    
    return false;
}

console.log(myInstanceOf(dog, Dog)); // true
```

---

### **5.3 Gotchas**

```javascript
// Primitives
console.log("hello" instanceof String); // false
console.log(new String("hello") instanceof String); // true

// Cross-frame objects (iframes)
const iframe = document.createElement('iframe');
document.body.appendChild(iframe);
const iframeArray = iframe.contentWindow.Array;

const arr = new iframeArray();
console.log(arr instanceof Array); // false!
console.log(Array.isArray(arr));   // true (better check)
```

---

## **PART 6: `constructor` Property**

### **6.1 What It Is**

Points back to the constructor function.

```javascript
function Person(name) {
    this.name = name;
}

const john = new Person("John");
console.log(john.constructor === Person); // true
```

---

### **6.2 Why It Can Break**

```javascript
function Animal() {}
function Dog() {}

Dog.prototype = Object.create(Animal.prototype);
// Now Dog.prototype.constructor points to Animal!

const dog = new Dog();
console.log(dog.constructor === Dog); // false!
console.log(dog.constructor === Animal); // true (wrong!)

// Fix:
Dog.prototype.constructor = Dog;
```

---

### **6.3 Creating Instances from Instances**

```javascript
function Person(name) {
    this.name = name;
}

const john = new Person("John");
const jane = new john.constructor("Jane");

console.log(jane.name); // "Jane"
console.log(jane instanceof Person); // true
```

---

## **PART 7: Complete Inheritance Patterns Comparison**

### **Pattern 1: Prototypal (Object.create)**

```javascript
const animal = {
    init(name) {
        this.name = name;
        return this;
    },
    eat() {
        console.log(`${this.name} eats`);
    }
};

const dog = Object.create(animal);
dog.init = function(name, breed) {
    animal.init.call(this, name);
    this.breed = breed;
    return this;
};
dog.bark = function() {
    console.log("Woof!");
};

const buddy = Object.create(dog).init("Buddy", "Lab");
```

**Pros:**

- Simple, no constructors
- Clear prototype chain

**Cons:**

- No `instanceof` support
- Manual initialization

---

### **Pattern 2: Constructor Functions**

```javascript
function Animal(name) {
    this.name = name;
}

Animal.prototype.eat = function() {
    console.log(`${this.name} eats`);
};

function Dog(name, breed) {
    Animal.call(this, name);
    this.breed = breed;
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
    console.log("Woof!");
};
```

**Pros:**

- Works everywhere
- `instanceof` support

**Cons:**

- Verbose
- Easy to mess up prototype chain

---

### **Pattern 3: ES6 Classes**

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    eat() {
        console.log(`${this.name} eats`);
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name);
        this.breed = breed;
    }
    
    bark() {
        console.log("Woof!");
    }
}
```

**Pros:**

- Clean syntax
- Familiar to C++/Java devs
- Less error-prone

**Cons:**

- Still prototypal under the hood
- No true private members (until #fields)

---

## **PART 8: Real-World Example**

```javascript
class Vehicle {
    constructor(brand, model) {
        this.brand = brand;
        this.model = model;
        this.speed = 0;
    }
    
    accelerate(amount) {
        this.speed += amount;
        console.log(`${this.brand} ${this.model} speed: ${this.speed}km/h`);
    }
    
    brake() {
        this.speed = 0;
        console.log("Vehicle stopped");
    }
}

class Car extends Vehicle {
    constructor(brand, model, doors) {
        super(brand, model);
        this.doors = doors;
    }
    
    honk() {
        console.log("Beep beep!");
    }
}

class ElectricCar extends Car {
    constructor(brand, model, doors, batteryLife) {
        super(brand, model, doors);
        this.batteryLife = batteryLife;
    }
    
    charge() {
        this.batteryLife = 100;
        console.log("Battery fully charged");
    }
    
    accelerate(amount) {
        super.accelerate(amount);
        this.batteryLife -= amount * 0.1;
        console.log(`Battery: ${this.batteryLife.toFixed(1)}%`);
    }
}

const tesla = new ElectricCar("Tesla", "Model 3", 4, 80);
tesla.accelerate(50);
// Output:
// Tesla Model 3 speed: 50km/h
// Battery: 75.0%

tesla.honk(); // "Beep beep!"
tesla.charge(); // "Battery fully charged"

console.log(tesla instanceof ElectricCar); // true
console.log(tesla instanceof Car);         // true
console.log(tesla instanceof Vehicle);     // true
```

---

## **Key Takeaways**

|**Concept**|**Use When**|
|---|---|
|`Object.create()`|Simple object cloning, no classes needed|
|Constructor functions|Legacy code, need `instanceof`|
|ES6 Classes|Modern code, clear hierarchy|
|`extends`|Inheriting behavior|
|`super`|Calling parent methods/constructor|
|`instanceof`|Type checking|
|`getPrototypeOf`|Inspecting prototype chain|

**What do you want to explore next?** Mixins? Composition vs inheritance? Symbol properties?