
---

# JavaScript Objects â€” the _real_ model

## 1. What an object actually is

In JS, an object is:

> **A collection of key â†’ value pairs + an internal prototype pointer**

```js
const obj = {
  a: 1,
  b: "hi",
  c() {}
};
```

Keys are **strings or symbols** (even if you write numbers).

```js
const o = { 1: "one" };
console.log(o["1"]); // "one"
```

â— Interview trap:  
`obj[1]` and `obj["1"]` are the same key.

---

## 2. Property access (dot vs bracket)

```js
obj.a        // dot
obj["a"]     // bracket
```

### Gotchas

```js
const key = "a";
obj.key      // âŒ undefined
obj[key]     // âœ… value
```

Bracket notation:

- required for dynamic keys
    
- required for invalid identifiers
    
- required for symbols
    

---

## 3. Objects are reference types

```js
const a = { x: 1 };
const b = a;

b.x = 2;
console.log(a.x); // 2
```

### Interview trap

```js
const a = {};
const b = {};
a === b; // false
```

Objects are compared by **reference**, not structure.

---

## 4. Shallow vs deep copy (huge trap)

### Shallow copy

```js
const copy = { ...obj };
const copy2 = Object.assign({}, obj);
```

Nested objects still share references.

```js
const o1 = { nested: { x: 1 } };
const o2 = { ...o1 };

o2.nested.x = 9;
console.log(o1.nested.x); // 9 âŒ
```

### Deep copy (not trivial)

```js
structuredClone(obj); // modern, best
```

â— Trap:

```js
JSON.parse(JSON.stringify(obj))
```

Breaks on:

- functions
    
- Dates
    
- Maps/Sets
    
- undefined
    
- circular refs
    

---

## 5. Property descriptors (low-level)

Every property has hidden flags:

```js
Object.getOwnPropertyDescriptor(obj, "a");
```

Flags:

- `writable`
    
- `enumerable`
    
- `configurable`
    

### Example trap

```js
Object.defineProperty(obj, "x", {
  value: 1,
  writable: false
});

obj.x = 2; // âŒ silently fails (or throws in strict mode)
```

---

## 6. Enumeration order (interview favorite)

Order when iterating:

1. Integer-like keys (`"0"`, `"1"`, `"2"`)
    
2. String keys (in insertion order)
    
3. Symbol keys
    

```js
const o = { b: 1, 1: "one", a: 2 };
console.log(Object.keys(o));
// ["1", "b", "a"]
```

---

## 7. `in` vs `hasOwn`

```js
"x" in obj             // checks prototype chain
obj.hasOwnProperty("x") // own properties only
```

### Trap

```js
const obj = Object.create({ x: 1 });
"x" in obj;             // true
obj.hasOwnProperty("x"); // false
```

Modern & safe:

```js
Object.hasOwn(obj, "x");
```

---

## 8. Prototype chain (core JS knowledge)

```js
obj.__proto__ === Object.prototype; // true
```

Property lookup:

1. own object
    
2. prototype
    
3. prototypeâ€™s prototype
    
4. null â†’ stop
    

### Trap

```js
obj.toString(); // exists even if not defined
```

Because it comes from `Object.prototype`.

---

## 9. `this` inside objects (big interview trap)

```js
const obj = {
  x: 1,
  getX() {
    return this.x;
  }
};
```

### Losing `this`

```js
const fn = obj.getX;
fn(); // undefined (or error in strict mode)
```

Why?  
Because `this` is determined by **call site**, not definition.

Fixes:

```js
fn.call(obj);
fn.bind(obj);
```

---

## 10. Methods vs arrow functions

```js
const obj = {
  x: 1,
  bad: () => this.x
};
```

âŒ Arrow functions do NOT have their own `this`.

Arrow `this` is lexically scoped.

---

## 11. Mutability & const trap

```js
const obj = { x: 1 };
obj.x = 2;  // âœ…
obj = {};   // âŒ
```

`const` protects the **binding**, not the object.

---

## 12. Object freezing (partial lies)

```js
Object.freeze(obj);
```

- prevents adding/removing/changing properties
    
- âŒ shallow freeze
    

```js
obj.nested.x = 5; // still works
```

---

## 13. Deleting properties

```js
delete obj.x;
```

### Trap

```js
delete obj.nonExistent; // true
```

Deleting array items:

```js
delete arr[0]; // leaves a hole
```

Better:

```js
arr.splice(0, 1);
```

---

## 14. Objects as maps (bad idea sometimes)

```js
const map = {};
map["__proto__"] = "oops"; // ðŸ’¥
```

Fix:

```js
const map = Object.create(null);
```

Or just use:

```js
new Map()
```

---

## 15. Equality traps

```js
{} == {}  // false
{} === {} // false
```

But:

```js
const a = {};
const b = a;
a === b; // true
```

---

## 16. Interview lightning-round traps

### Q: Can object keys be objects?

```js
const o = {};
o[{ x: 1 }] = "hi";
```

Answer:  
Yes â€” but theyâ€™re stringified:

```js
"[object Object]"
```

Use `Map` instead.

---

### Q: Difference between `Object.keys`, `values`, `entries`?

- enumerable
    
- own properties only
    
- excludes symbols
    

---

### Q: What happens if property doesnâ€™t exist?

```js
obj.x; // undefined
```

But:

```js
obj.x.y; // ðŸ’¥ TypeError
```

Optional chaining:

```js
obj.x?.y;
```

---

## 17. The ONE mental model to remember

> Objects are mutable dictionaries with hidden metadata and a prototype chain; references are shared unless explicitly copied.

---

next:

- **Prototypes & inheritance deep dive**
    
- **`this`, `call`, `apply`, `bind` torture tests**
    
- **Objects vs Maps (performance + semantics)**
    
- **Real interview questions from FAANG / startups**