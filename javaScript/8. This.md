

1. âœ… Simple intuition
    
2. âœ… Formal definition (interview-ready)
    
3. âœ… All binding rules
    
4. âœ… Edge cases
    

---

# ðŸ§  Simple Intuition

`this` is:

> The object that is executing the current function.

But thatâ€™s informal.

Letâ€™s go formal.

---

# ðŸ“˜ Formal Definition

> In JavaScript, `this` is a special keyword whose value is determined by how a function is called (its call-site), not where it is defined (except for arrow functions).

Or even more formal:

> `this` is a runtime binding that refers to the execution context object associated with a function invocation.

Thatâ€™s the clean interview definition.

---

# ðŸ”¥ Most Important Rule

`this` is decided at **call time**, not at **definition time**.

---

# ðŸŽ¯ The 4 Binding Rules (Must Know)

These rules determine what `this` becomes.

---

## 1ï¸âƒ£ Default Binding

If a normal function is called without an object:

```js
function sayHi() {
  console.log(this);
}

sayHi();
```

In browser:

- `this` â†’ `window`
    

In Node (non-strict):

- `this` â†’ `global`
    

In strict mode:

- `this` â†’ `undefined`
    

---

## 2ï¸âƒ£ Implicit Binding (Object Method Call)

```js
const user = {
  name: "Hulk",
  sayHi() {
    console.log(this.name);
  }
};

user.sayHi();
```

Here:

- `this` â†’ `user`
    

Rule:

> When a function is called as a method of an object, `this` refers to that object.

---

## 3ï¸âƒ£ Explicit Binding (`call`, `apply`, `bind`)

```js
function greet() {
  console.log(this.name);
}

const obj = { name: "Thor" };

greet.call(obj);
```

Now:

- `this` â†’ `obj`
    

You manually set it.

---

## 4ï¸âƒ£ Constructor Binding (`new` keyword)

```js
function Hero(name) {
  this.name = name;
}

const h1 = new Hero("Hulk");
```

Here:

- `this` â†’ newly created object
    

Rule:

> When a function is called with `new`, `this` refers to the newly created instance.

---

# ðŸš¨ Arrow Functions (Special Case)

Arrow functions do NOT have their own `this`.

They inherit `this` from their lexical (outer) scope.

```js
const obj = {
  name: "Spiderman",
  sayHi: () => {
    console.log(this.name);
  }
};

obj.sayHi();
```

This does NOT refer to `obj`.

Because arrow functions:

> Capture `this` from surrounding context.

Formal rule:

> Arrow functions perform lexical `this` binding.

---

# ðŸ§© Summary Table

|How Function Is Called|What `this` Becomes|
|---|---|
|Normal function call|global / undefined|
|Method call|Object before dot|
|call/apply/bind|Explicitly set value|
|With `new`|New instance|
|Arrow function|Inherited from outer scope|

---

# ðŸ§  Advanced Understanding

Internally, when a function runs:

1. Execution context is created.
    
2. `this` is bound based on call-site rules.
    
3. The function body executes with that `this`.
    

So `this` is not a property of the function itself.

Itâ€™s part of the functionâ€™s execution context.

---

# ðŸŽ¯ Interview-Level One-Liner

If asked:

"What is `this` in JavaScript?"

Answer:

> `this` is a dynamically bound keyword that refers to the object associated with the current function call, determined by the call-site. In arrow functions, it is lexically inherited from the surrounding scope.

Thatâ€™s a strong answer.

---
