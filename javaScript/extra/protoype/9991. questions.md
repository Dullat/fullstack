

- ðŸŸ¢ Level 1 â€” Core understanding
    
- ðŸŸ¡ Level 2 â€” Code tracing
    
- ðŸŸ  Level 3 â€” Prototype manipulation
    
- ðŸ”´ Level 4 â€” Deep internals
    
- ðŸ§  Bonus â€” Concepts people forget
    


---

# ðŸŸ¢ LEVEL 1 â€” Core Prototype Fundamentals

1. What is the difference between:
    
    - `.prototype`
        
    - `__proto__`
        
    - `Object.getPrototypeOf()`
        
2. Does every object have a `.prototype` property?
    
3. Does every object have a `__proto__`?
    
4. What does `new` actually do internally? List all steps.
    
5. What happens if a constructor explicitly returns an object?
    
6. What happens if a constructor returns a primitive?
    
7. What is the default value of `Function.prototype.__proto__`?
    
8. What is the default value of `Object.prototype.__proto__`?
    
9. Why does this work?
    

```js
"abc".toUpperCase()
```

10. What is the difference between:
    

```js
new String("abc")
```

and

```js
"abc"
```

---

# ðŸŸ¡ LEVEL 2 â€” Code Prediction (Very Common in Interviews)

### 1ï¸âƒ£

```js
function A() {}
const a = new A();

console.log(a.__proto__ === A.prototype);
console.log(A.__proto__ === Function.prototype);
console.log(A.prototype.__proto__ === Object.prototype);
```

---

### 2ï¸âƒ£

```js
function A() {}
A.prototype.x = 10;

const a1 = new A();
const a2 = new A();

a1.x = 20;

console.log(a1.x);
console.log(a2.x);
```

---

### 3ï¸âƒ£

```js
function A() {}
const a = new A();

A.prototype.say = function() {
  return "hello";
};

console.log(a.say());
```

Does it work? Why?

---

### 4ï¸âƒ£

```js
function A() {}
A.prototype = {
  say() { return "hi"; }
};

const a = new A();
console.log(a.constructor === A);
```

What prints?

---

### 5ï¸âƒ£

```js
function A() {}
const a = new A();

A.prototype = {};

console.log(a.__proto__ === A.prototype);
```

---

### 6ï¸âƒ£

```js
function A() {}
A.prototype.x = 10;

const a = new A();

delete a.x;
delete A.prototype.x;

console.log(a.x);
```

---

# ðŸŸ  LEVEL 3 â€” Prototype Chain Manipulation

### 7ï¸âƒ£ Manual inheritance

```js
function Parent() {}
Parent.prototype.say = function() { return "parent"; }

function Child() {}
Child.prototype = Object.create(Parent.prototype);

const c = new Child();

console.log(c.say());
```

Why does this work?

---

### 8ï¸âƒ£ What is wrong here?

```js
Child.prototype = Parent.prototype;
```

Why is this dangerous?

---

### 9ï¸âƒ£ Fix constructor reference

After:

```js
Child.prototype = Object.create(Parent.prototype);
```

Why do we often write:

```js
Child.prototype.constructor = Child;
```

What problem does it fix?

---

### ðŸ”Ÿ

What does this create?

```js
const obj = Object.create(null);
```

What methods does it NOT have?

---

# ðŸ”´ LEVEL 4 â€” Deep Internals

### 1ï¸âƒ£

Explain why this is true:

```js
Function instanceof Function
```

---

### 2ï¸âƒ£

Explain why this is also true:

```js
Object instanceof Function
```

---

### 3ï¸âƒ£

Explain the full prototype chain of:

```js
Array
```

---

### 4ï¸âƒ£

Explain the full prototype chain of:

```js
[]
```

---

### 5ï¸âƒ£

Why does this return true?

```js
[] instanceof Object
```

Explain how `instanceof` works internally.

---

### 6ï¸âƒ£

Recreate how `instanceof` works manually.

Implement:

```js
function myInstanceOf(obj, constructor) {
  // ?
}
```

---

### 7ï¸âƒ£

What happens here?

```js
function A() {}
A.prototype = null;

const a = new A();
```

What is `a.__proto__`?

---

### 8ï¸âƒ£

What is the difference between:

```js
Object.setPrototypeOf(obj, proto)
```

and

```js
obj.__proto__ = proto
```

Which is preferred and why?

---

# ðŸ§  BONUS â€” Things People Forget

1. What is the difference between:
    
    - `hasOwnProperty`
        
    - `in`
        
    - `Object.hasOwn()`
        
2. What happens if you override `toString` on `Object.prototype`?
    
3. Why is modifying built-in prototypes considered dangerous?
    
4. What is prototype pollution?
    
5. What is the performance cost of deep prototype chains?
    
6. How does `class` translate internally to prototype code?
    
7. What is the difference between:
    
    - ES6 class methods
        
    - Methods defined inside constructor
        
8. Why are arrow functions bad for prototype methods?
    
9. Why does this fail?
    

```js
Hero.prototype.sayHi = () => {
  console.log(this.name);
};
```

10. What is the difference between:
    

- `Object.create(proto)`
    
- `new Constructor()`
    

---

# ðŸ’€ FINAL BOSS

Explain this entire diagram without hesitation:

```
Function
   â†“
Function.prototype
   â†“
Object.prototype
   â†“
null

Object
   â†“
Function.prototype

Array
   â†“
Function.prototype

[]
   â†“
Array.prototype
   â†“
Object.prototype
   â†“
null
```

---
# Answers



---

# ðŸŸ¢ LEVEL 1 â€” Core Fundamentals

---

### 1ï¸âƒ£ `.prototype` vs `__proto__` vs `Object.getPrototypeOf`

- **`.prototype`**
    
    - Exists only on functions.
        
    - Used when creating objects with `new`.
        
    - Becomes the `__proto__` of instances.
        
- **`__proto__`**
    
    - Exists on objects.
        
    - Points to the object it inherits from.
        
    - Legacy accessor for internal `[[Prototype]]`.
        
- **`Object.getPrototypeOf(obj)`**
    
    - Official way to read `[[Prototype]]`.
        

---

### 2ï¸âƒ£ Does every object have `.prototype`?

âŒ No.  
Only functions have `.prototype`.

---

### 3ï¸âƒ£ Does every object have `__proto__`?

Almost all normal objects do (via `Object.prototype`),  
but objects created with:

```js
Object.create(null)
```

do NOT.

---

### 4ï¸âƒ£ What does `new` do?

Internally:

1. Create empty object `{}`
    
2. Set its `[[Prototype]]` to `Constructor.prototype`
    
3. Call constructor with `this` bound to that object
    
4. Return object (unless constructor returns an object explicitly)
    

---

### 5ï¸âƒ£ Constructor returns object?

That object replaces the default return.

---

### 6ï¸âƒ£ Constructor returns primitive?

Ignored. The created object is returned.

---

### 7ï¸âƒ£ `Function.prototype.__proto__`

```js
Function.prototype.__proto__ === Object.prototype
```

---

### 8ï¸âƒ£ `Object.prototype.__proto__`

```js
Object.prototype.__proto__ === null
```

Root of everything.

---

### 9ï¸âƒ£ Why does `"abc".toUpperCase()` work?

Primitive string is temporarily wrapped in a `String` object,  
which inherits from `String.prototype`.

---

### ðŸ”Ÿ `"abc"` vs `new String("abc")`

- `"abc"` â†’ primitive
    
- `new String("abc")` â†’ object
    

```js
typeof "abc"           // "string"
typeof new String()    // "object"
```

---

# ðŸŸ¡ LEVEL 2 â€” Code Answers

---

### 1ï¸âƒ£ All three logs

All are `true`.

---

### 2ï¸âƒ£

```js
a1.x = 20
```

Creates own property.

Output:

```
20
10
```

---

### 3ï¸âƒ£

Yes, works.

Because prototype is looked up at runtime.

---

### 4ï¸âƒ£

`false`

Because when you overwrite:

```js
A.prototype = { say() {} }
```

You removed the default `constructor` reference.

---

### 5ï¸âƒ£

`false`

Because `a` was linked to old prototype object.

---

### 6ï¸âƒ£

`undefined`

You deleted both own and prototype property.

---

# ðŸŸ  LEVEL 3 â€” Inheritance

---

### 7ï¸âƒ£ Why does manual inheritance work?

```js
Child.prototype = Object.create(Parent.prototype);
```

Because it creates a new object whose `[[Prototype]]` is `Parent.prototype`.

So:

```
c â†’ Child.prototype â†’ Parent.prototype
```

---

### 8ï¸âƒ£ Why is this dangerous?

```js
Child.prototype = Parent.prototype;
```

Now both share SAME object.

Modifying one modifies both.

---

### 9ï¸âƒ£ Why fix constructor?

After `Object.create`, constructor points to `Parent`.

So we reset:

```js
Child.prototype.constructor = Child;
```

---

### ðŸ”Ÿ `Object.create(null)`

Creates object with NO prototype.

No:

- `toString`
    
- `hasOwnProperty`
    
- `__proto__`
    

Good for pure dictionaries.

---

# ðŸ”´ LEVEL 4 â€” Deep Internals

---

### 1ï¸âƒ£ Why `Function instanceof Function`?

Because:

```
Function.__proto__ === Function.prototype
```

So `instanceof` finds it in chain.

---

### 2ï¸âƒ£ Why `Object instanceof Function`?

Because:

```
Object.__proto__ === Function.prototype
```

---

### 3ï¸âƒ£ Prototype chain of `Array`

```
Array
   â†“
Function.prototype
   â†“
Object.prototype
   â†“
null
```

---

### 4ï¸âƒ£ Prototype chain of `[]`

```
[]
   â†“
Array.prototype
   â†“
Object.prototype
   â†“
null
```

---

### 5ï¸âƒ£ Why `[] instanceof Object`?

Because `Object.prototype` exists in its chain.

---

### 6ï¸âƒ£ Manual `instanceof`

```js
function myInstanceOf(obj, constructor) {
  let proto = Object.getPrototypeOf(obj);

  while (proto !== null) {
    if (proto === constructor.prototype) return true;
    proto = Object.getPrototypeOf(proto);
  }

  return false;
}
```

---

### 7ï¸âƒ£ If `A.prototype = null`

`new A()` will default to `Object.prototype`.

Spec says: if prototype is not object, fallback to `Object.prototype`.

---

### 8ï¸âƒ£ `Object.setPrototypeOf` vs `__proto__`

- `__proto__` is legacy.
    
- `Object.setPrototypeOf` is standard.
    
- Both are slow.
    
- Best: set prototype at creation time.
    

---

# ðŸ§  BONUS

---

### `hasOwnProperty` vs `in`

- `hasOwnProperty` â†’ checks own properties only.
    
- `in` â†’ checks entire prototype chain.
    
- `Object.hasOwn(obj, prop)` â†’ modern safer version.
    

---

### Modifying built-ins dangerous?

Because it affects ALL objects globally.

---

### Prototype pollution?

Attacker injects properties into `Object.prototype`.

Example:

```js
Object.prototype.isAdmin = true;
```

Now every object has it.

Security issue.

---

### Performance cost?

Deep chains = slower property lookup.

---

### Class translation

```js
class Hero {
  sayHi() {}
}
```

Becomes:

```js
function Hero() {}
Hero.prototype.sayHi = function() {}
```

---

### Arrow functions bad for prototype methods?

Because arrow functions donâ€™t have their own `this`.

They capture lexical `this`.

---

### Why this fails?

```js
Hero.prototype.sayHi = () => {
  console.log(this.name);
};
```

`this` is not instance â€” itâ€™s outer scope.

---

# ðŸ’€ FINAL BOSS EXPLAINED

Two worlds:

### Constructor world:

All constructors:

```
â†’ Function.prototype
â†’ Object.prototype
â†’ null
```

### Instance world:

Instances:

```
â†’ Constructor.prototype
â†’ Object.prototype
â†’ null
```

Everything eventually ends at:

```
Object.prototype â†’ null
```

---

# ðŸŽ¯ Final Summary

JavaScript has:

- Objects
    
- Functions (which are objects)
    
- Prototype delegation
    
- No real classical classes
    
- Two parallel chains:
    
    - Constructor chain
        
    - Instance chain
        

---
