# Deep Dive: `this`, `window`, and Global Object

Let's break this down systematically.

---

## **1. The Global Object**

**What it is:** A top-level object that holds global variables and functions.

**Different environments:**

- **Browser:** `window`
- **Node.js:** `global`
- **Both (modern):** `globalThis` (standardized)

```javascript
// Browser
console.log(window === globalThis); // true

// Node.js
console.log(global === globalThis); // true
```

**What's stored there:**

```javascript
// Browser example
var x = 10; // Creates window.x
function foo() {} // Creates window.foo

console.log(window.x); // 10
console.log(window.foo); // function foo() {}
```

⚠️ **Important:** `let`, `const`, and `class` do NOT create properties on the global object:

```javascript
var a = 1;
let b = 2;
const c = 3;

console.log(window.a); // 1
console.log(window.b); // undefined
console.log(window.c); // undefined
```

---

## **2. What is `this`?**

`this` is a **dynamic context** that changes based on **how a function is called**.

Think of it like C++ `this`, but it's **not fixed**—it changes!

---

## **3. The 5 Rules of `this`**

### **Rule 1: Default Binding (Global Context)**

```javascript
function foo() {
    console.log(this);
}

foo(); // In browser: window
       // In Node.js: global (or undefined in strict mode)
```

**In strict mode:**

```javascript
'use strict';
function foo() {
    console.log(this);
}

foo(); // undefined (not global object)
```

---

### **Rule 2: Implicit Binding (Object Method)**

When you call a function as a **method** of an object, `this` is that object.

```javascript
const person = {
    name: "John",
    greet: function() {
        console.log(this.name);
    }
};

person.greet(); // "John" (this = person)
```

**BUT WATCH OUT:**

```javascript
const greet = person.greet;
greet(); // undefined (this is now global/undefined in strict mode)
```

Why? Because `greet()` is no longer called on an object—it's just a standalone function.

---

### **Rule 3: Explicit Binding (call, apply, bind)**

You can **force** what `this` should be.

#### **`call()`**

```javascript
function greet() {
    console.log(`Hi, I'm ${this.name}`);
}

const person = { name: "Alice" };
greet.call(person); // "Hi, I'm Alice"
```

#### **`apply()` (same, but arguments as array)**

```javascript
function introduce(age, city) {
    console.log(`${this.name}, ${age}, from ${city}`);
}

introduce.apply(person, [25, "NYC"]); // "Alice, 25, from NYC"
```

#### **`bind()` (returns a new function with `this` locked)**

```javascript
const boundGreet = greet.bind(person);
boundGreet(); // "Hi, I'm Alice" (this is permanently person)
```

**Use case:** Event handlers

```javascript
class Button {
    constructor(label) {
        this.label = label;
    }
    
    click() {
        console.log(`${this.label} clicked`);
    }
}

const btn = new Button("Submit");

// Problem:
document.querySelector('#btn').addEventListener('click', btn.click);
// Error! this.label is undefined (this = the DOM element)

// Solution:
document.querySelector('#btn').addEventListener('click', btn.click.bind(btn));
// Now this = btn object
```

---

### **Rule 4: `new` Binding (Constructor)**

When you use `new`, `this` is the newly created object.

```javascript
function Person(name) {
    this.name = name; // this = new empty object
}

const john = new Person("John");
console.log(john.name); // "John"
```

**What `new` does:**

1. Creates an empty object `{}`
2. Sets `this` to that object
3. Links it to `Person.prototype`
4. Returns `this` (unless you explicitly return an object)

---

### **Rule 5: Arrow Functions (Lexical `this`)**

Arrow functions **don't have their own `this`**—they inherit it from the surrounding scope.

```javascript
const person = {
    name: "Bob",
    greet: function() {
        const inner = () => {
            console.log(this.name); // this = person (inherited)
        };
        inner();
    }
};

person.greet(); // "Bob"
```

**Compare with regular function:**

```javascript
const person = {
    name: "Bob",
    greet: function() {
        const inner = function() {
            console.log(this.name); // this = undefined (or window)
        };
        inner();
    }
};

person.greet(); // undefined
```

**Use case:** Callbacks

```javascript
class Timer {
    constructor() {
        this.seconds = 0;
    }
    
    start() {
        setInterval(() => {
            this.seconds++; // this = Timer instance
            console.log(this.seconds);
        }, 1000);
    }
}

const timer = new Timer();
timer.start(); // 1, 2, 3...
```

If you used a regular function, `this` would be `window` (or `undefined`).

---

## **4. Priority Order (When Multiple Rules Apply)**

1. **`new` binding** (highest)
2. **Explicit binding** (`call`, `apply`, `bind`)
3. **Implicit binding** (object method)
4. **Default binding** (global or undefined)

```javascript
function foo() {
    console.log(this.name);
}

const obj1 = { name: "Obj1", foo };
const obj2 = { name: "Obj2" };

obj1.foo(); // "Obj1" (implicit)
obj1.foo.call(obj2); // "Obj2" (explicit beats implicit)

const boundFoo = obj1.foo.bind(obj2);
boundFoo(); // "Obj2" (bind beats implicit)

new boundFoo(); // undefined (new beats bind, creates new object)
```

---

## **5. Common Pitfalls**

### **Losing `this` in Callbacks**

```javascript
class MyClass {
    constructor() {
        this.value = 42;
    }
    
    doSomething() {
        setTimeout(function() {
            console.log(this.value); // undefined (this = window/global)
        }, 1000);
    }
}

new MyClass().doSomething();
```

**Solutions:**

```javascript
// 1. Arrow function
setTimeout(() => {
    console.log(this.value); // 42
}, 1000);

// 2. bind
setTimeout(function() {
    console.log(this.value); // 42
}.bind(this), 1000);

// 3. Store this in a variable (old way)
const self = this;
setTimeout(function() {
    console.log(self.value); // 42
}, 1000);
```

---

### **`this` in Event Listeners**

```javascript
const button = {
    label: "Click me",
    click: function() {
        console.log(this.label);
    }
};

document.querySelector('button').addEventListener('click', button.click);
// undefined (this = the button DOM element)

// Fix:
document.querySelector('button').addEventListener('click', button.click.bind(button));
```

---

## **6. Window Object Specifics (Browser)**

**Built-in properties:**

```javascript
window.location.href // Current URL
window.document // The DOM
window.setTimeout // Timer functions
window.localStorage // Storage API
window.alert // Dialogs
```

**Global variables:**

```javascript
var globalVar = "I'm global";
console.log(window.globalVar); // "I'm global"

function globalFunc() {}
console.log(window.globalFunc); // function globalFunc() {}
```

**Accessing from nested scope:**

```javascript
function outer() {
    function inner() {
        console.log(window); // Still accessible
    }
    inner();
}
```

---

## **7. Global Object in Node.js**

```javascript
// In a .js file (not in a function)
console.log(this); // {} (empty object, the module.exports)

// Inside a function
function foo() {
    console.log(this); // global object (or undefined in strict mode)
}
```

---

## **8. Real-World Scenarios**

### **Scenario 1: Class Methods**

```javascript
class Counter {
    constructor() {
        this.count = 0;
    }
    
    increment() {
        this.count++;
    }
}

const counter = new Counter();
const increment = counter.increment;

increment(); // Error! this is undefined
counter.increment(); // Works! this = counter
```

### **Scenario 2: Array Methods**

```javascript
const obj = {
    values: [1, 2, 3],
    double: function() {
        return this.values.map(function(v) {
            return v * 2;
        });
    }
};

obj.double(); // [2, 4, 6] (works, but...)

// What if you need 'this' inside map?
const obj2 = {
    multiplier: 2,
    values: [1, 2, 3],
    multiply: function() {
        return this.values.map(function(v) {
            return v * this.multiplier; // Error! this is undefined
        });
    }
};

// Fix 1: Arrow function
multiply: function() {
    return this.values.map(v => v * this.multiplier); // Works!
}

// Fix 2: thisArg parameter
multiply: function() {
    return this.values.map(function(v) {
        return v * this.multiplier;
    }, this); // Pass 'this' as second argument
}
```

---

## **Quick Reference Table**

|**Context**|**`this` refers to**|
|---|---|
|Global scope (browser)|`window`|
|Global scope (Node.js)|`global` or `{}` (module)|
|Regular function|`window`/`global` or `undefined` (strict)|
|Object method|The object|
|`call`/`apply`/`bind`|Whatever you pass|
|Constructor (`new`)|The new object|
|Arrow function|Inherited from parent scope|
|Event listener|The DOM element (unless bound)|

---
