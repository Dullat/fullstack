
---

## **1. Constructor Functions (The Old Way)**

**What it is:** A function that creates objects using `new`.

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
}

const john = new Person("John", 25);
```

**When to use:** You rarely use this anymore. Use **classes** instead (we'll get there).

**Why it exists:** Before ES6 classes, this was the only way to create reusable object templates.

---

## **2. The `prototype` Property**

**What it is:** Every function has a `.prototype` property. When you use `new`, the created object links to this prototype.

```javascript
function Person(name) {
    this.name = name;
}

// Add a method to the prototype (shared by all instances)
Person.prototype.greet = function() {
    console.log(`Hi, I'm ${this.name}`);
};

const john = new Person("John");
john.greet(); // "Hi, I'm John"
```

**When to use:** When you want all instances to **share methods** instead of each object having its own copy.

**Why it exists:** Memory efficiency. If 1000 objects all have the same method, storing it once (in the prototype) saves memory.

---

## **3. The `__proto__` Property (Internal Link)**

**What it is:** Every object has a hidden `__proto__` property that points to its prototype.

```javascript
console.log(john.__proto__ === Person.prototype); // true
```

**When to use:** **Never directly**. It's deprecated. Use `Object.getPrototypeOf()` instead.

**Why it exists:** It's the internal mechanism JavaScript uses for prototype chain lookups.

---

## **4. `Object.getPrototypeOf()` (The Right Way)**

**What it is:** Returns the prototype of an object.

```javascript
console.log(Object.getPrototypeOf(john) === Person.prototype); // true
```

**When to use:** When you need to inspect or check what an object's prototype is.

---

## **5. `Object.create()` (Manual Prototype Linking)**

**What it is:** Creates a new object with a specific prototype.

```javascript
const personPrototype = {
    greet() {
        console.log(`Hi, I'm ${this.name}`);
    }
};

const john = Object.create(personPrototype);
john.name = "John";
john.greet(); // "Hi, I'm John"
```

**When to use:** When you want **simple inheritance without constructors**.

**Why it exists:** Gives you control over the prototype without needing `new` or constructor functions.

---

## **6. The Prototype Chain**

**What it is:** When you access a property, JavaScript looks at:

1. The object itself
2. Its prototype
3. Its prototype's prototype
4. ... until it reaches `null`

```javascript
const obj = { a: 1 };
console.log(obj.toString()); // Works! toString is in Object.prototype

// Chain: obj -> Object.prototype -> null
```

**When to use:** You don't "use" it—it just happens. But understanding it helps debug "undefined" errors.

---

## **7. `instanceof` Operator**

**What it is:** Checks if an object was created by a specific constructor.

```javascript
console.log(john instanceof Person); // true
console.log(john instanceof Object); // true (everything inherits from Object)
```

**When to use:** Type checking (though `typeof` or duck typing is often better).

---

## **8. Inheritance (The Modern Way: Classes)**

**What it is:** One class extending another.

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        console.log(`${this.name} makes a sound`);
    }
}

class Dog extends Animal {
    speak() {
        console.log(`${this.name} barks`);
    }
}

const dog = new Dog("Rex");
dog.speak(); // "Rex barks"
```

**When to use:** When you have shared behavior across related objects (like C++ inheritance).

**Why it exists:** Code reuse. DRY principle.

---

## **9. When to Use What?**

|**Goal**|**Use This**|
|---|---|
|Create multiple similar objects|**Class**|
|Share methods across instances|**Class** (methods auto-go to prototype)|
|Inherit from another class|**`extends`** keyword|
|Create object with specific prototype|**`Object.create()`**|
|Check what created an object|**`instanceof`**|
|Get an object's prototype|**`Object.getPrototypeOf()`**|

---

## **10. Real-World Example: Building a Game**

```javascript
class Character {
    constructor(name, health) {
        this.name = name;
        this.health = health;
    }
    
    takeDamage(amount) {
        this.health -= amount;
        console.log(`${this.name} took ${amount} damage. Health: ${this.health}`);
    }
}

class Warrior extends Character {
    constructor(name, health, armor) {
        super(name, health); // Call parent constructor
        this.armor = armor;
    }
    
    takeDamage(amount) {
        const reduced = amount - this.armor;
        super.takeDamage(reduced); // Call parent method
    }
}

const hero = new Warrior("Conan", 100, 10);
hero.takeDamage(30); // "Conan took 20 damage. Health: 80"
```

**Why inheritance here?** Because warriors ARE characters, but with armor logic.

---

## **The Big Picture**

```
Constructor Function (old) → Class (new, cleaner syntax)
        ↓                            ↓
    .prototype ←────────────── Methods stored here
        ↓
   __proto__ (internal link, don't touch)
        ↓
Object.getPrototypeOf() (safe way to inspect)
        ↓
Object.create() (manual prototype setting)
```

---
